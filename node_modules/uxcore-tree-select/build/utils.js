'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.flatToHierarchy = flatToHierarchy;
exports.isMultipleOrTags = isMultipleOrTags;
exports.isMultipleOrTagsOrCombobox = isMultipleOrTagsOrCombobox;
exports.isSingleMode = isSingleMode;

var _util = require('rc-tree-select/lib/util');

// Refactor
function flatToHierarchy(arr) {
  var flag = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

  if (!arr.length) {
    return arr;
  }
  var hierarchyNodes = [];
  var levelObj = {};
  arr.forEach(function (item) {
    if (!item.pos) {
      return;
    }
    var posLen = item.pos.split('-').length;
    if (!levelObj[posLen]) {
      levelObj[posLen] = [];
    }
    levelObj[posLen].push(item);
  });
  // levelObj 收集每个层级的child
  var levelArr = Object.keys(levelObj).sort(function (a, b) {
    return b - a;
  });

  // const s = Date.now();
  // todo: there are performance issues!
  levelArr.reduce(function (pre, cur) {
    if (cur && cur !== pre) {
      levelObj[pre].forEach(function (item) {
        var haveParent = false;
        levelObj[cur].forEach(function (ii) {
          if ((0, _util.isPositionPrefix)(ii.pos, item.pos)) {
            haveParent = true;
            // select multiple模式下的筛选
            if (flag && ii.isAll) {
              return;
            }
            if (!ii.children) {
              ii.children = []; // eslint-disable-line
            }
            ii.children.push(item);
          }
        });
        if (!haveParent) {
          hierarchyNodes.push(item);
        }
      });
    }
    return cur;
  });
  // console.log(Date.now() - s);
  return levelObj[levelArr[levelArr.length - 1]].concat(hierarchyNodes);
}

function isMultipleOrTags(props) {
  return !!((0, _util.isMultiple)(props) || props.tags);
}

function isMultipleOrTagsOrCombobox(props) {
  return (0, _util.isMultiple)(props) || props.tags || props.combobox;
}

function isSingleMode(props) {
  return !((0, _util.isMultiple)(props) || props.tags || props.combobox);
}