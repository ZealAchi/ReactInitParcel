'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _classnames = require('classnames');

var _classnames2 = _interopRequireDefault(_classnames);

var _propTypes = require('prop-types');

var _propTypes2 = _interopRequireDefault(_propTypes);

var _uploadcore = require('uploadcore');

var _uxcoreButton = require('uxcore-button');

var _uxcoreButton2 = _interopRequireDefault(_uxcoreButton);

var _reactLifecyclesCompat = require('react-lifecycles-compat');

var _util = require('./util');

var _util2 = _interopRequireDefault(_util);

var _FileList = require('./FileList');

var _FileList2 = _interopRequireDefault(_FileList);

var _Picker = require('./Picker');

var _Picker2 = _interopRequireDefault(_Picker);

var _Dropzoom = require('./Dropzoom');

var _Dropzoom2 = _interopRequireDefault(_Dropzoom);

var _locale = require('./locale');

var _locale2 = _interopRequireDefault(_locale);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

var RESETOPTIONS = ['name', 'url', 'params', 'action', 'data', 'headers', 'withCredentials', 'timeout', 'chunkEnable', 'chunkSize', 'chunkRetries', 'chunkProcessThreads', 'autoPending', 'auto', 'sizeLimit', 'fileSizeLimit', 'queueCapcity'];

var Uploader = function (_React$Component) {
  _inherits(Uploader, _React$Component);

  Uploader.getDerivedStateFromProps = function getDerivedStateFromProps(nextProps, prevState) {
    if (!_util2["default"].simpleDeepEqual(nextProps.fileList, prevState.preFileList)) {
      return {
        fileList: Uploader.processDefaultList(_util2["default"].simpleDeepCopy(nextProps.fileList)),
        preFileList: nextProps.fileList
      };
    }
    return prevState;
  };

  /**
  * process file in this.props.fileList
  */


  Uploader.processDefaultListFile = function processDefaultListFile(file) {
    var newFile = file;
    if (!file.type) newFile.type = 'list';

    // if there is no response, we create one if developers provide necessary values in top level
    if (!newFile.response) {
      var rdata = {
        name: file.name,
        downloadUrl: file.url || '',
        previewUrl: file.previewUrl || file.url || '',
        canRemove: file.canRemove || true
      };

      if (newFile.type === 'upload') {
        newFile.response = {
          content: rdata
        };
      } else {
        newFile.response = rdata;
      }
    }

    return newFile;
  };

  Uploader.processFile = function processFile(file) {
    var response = file.response ? file.response.getJson() : null;
    var rcontent = response && response.content ? response.content : {};
    return {
      id: rcontent.id || '',
      url: rcontent.url || rcontent.downloadUrl || rcontent.previewUrl || '',
      previewUrl: rcontent.previewUrl || '',
      ext: file.ext,
      name: file.name,
      size: file.size,
      fileType: file.type,
      type: 'upload',
      response: response
    };
  };

  /**
  * deepcopy props.filelist for comparision in `componentWillReceiveProps`
  */


  Uploader.addUniqueIdForList = function addUniqueIdForList(fileList) {
    var newList = _util2["default"].simpleDeepCopy(fileList);
    newList = newList.map(function (file, index) {
      var newFile = file;
      newFile.__uploaderId = 'uploader' + index;
      return newFile;
    });
    return newList;
  };

  Uploader.processDefaultList = function processDefaultList(fileList) {
    return Uploader.addUniqueIdForList(fileList).map(function (file) {
      return Uploader.processDefaultListFile(file);
    });
  };

  function Uploader(props) {
    _classCallCheck(this, Uploader);

    var _this = _possibleConstructorReturn(this, _React$Component.call(this, props));

    _this.core = _util2["default"].getCoreInstance(props);
    _this.state = {
      total: _this.core.getTotal(),
      fileList: Uploader.processDefaultList(_util2["default"].simpleDeepCopy(props.fileList)),
      preFileList: props.fileList
    };
    _this.init();
    return _this;
  }

  Uploader.prototype.componentDidUpdate = function componentDidUpdate(prevProps) {
    var _this2 = this;

    var options = {};
    RESETOPTIONS.forEach(function (item) {
      if (_this2.props.hasOwnProperty(item) && _this2.props[item] !== prevProps[item]) {
        options[item] = _this2.props[item];
      }
    });
    if (this.core.setOptions) this.core.setOptions(options);
  };

  Uploader.prototype.componentWillUnmount = function componentWillUnmount() {
    this.stopListen();
  };

  Uploader.prototype.getCore = function getCore() {
    return this.core;
  };

  Uploader.prototype.getUploadingFiles = function getUploadingFiles() {
    return this.core.getFiles().filter(function (file) {
      return [_uploadcore.Status.CANCELLED, _uploadcore.Status.SUCCESS, _uploadcore.Status.QUEUED].indexOf(file.status) === -1;
    });
  };

  Uploader.prototype.getNotDeletedDefaultFiles = function getNotDeletedDefaultFiles() {
    return (this.state.fileList || []).filter(function (file) {
      return !file.type || file.type !== 'delete';
    });
  };

  Uploader.prototype.stopListen = function stopListen() {
    this.core.off(_uploadcore.Events.QUEUE_STAT_CHANGE, this.statchange);
    this.core.off(_uploadcore.Events.FILE_UPLOAD_SUCCESS, this.fileuploadsuccess);
    this.core.off(_uploadcore.Events.FILE_CANCEL, this.filecancel);
  };

  Uploader.prototype.reset = function reset() {
    var _this3 = this;

    this.core.getFiles().forEach(function (file) {
      file.cancel(true);
      _this3.core.getStat().remove(file);
    });
    this.forceUpdate();
  };

  Uploader.prototype.handleRemoveFile = function handleRemoveFile(file) {
    var me = this;
    var newList = _util2["default"].simpleDeepCopy(me.state.fileList);
    newList = newList.map(function (item) {
      var newItem = item;
      if (item.__uploaderId === file.__uploaderId) {
        newItem.subType = item.type;
        newItem.type = 'delete';
      }
      return newItem;
    });
    me.handleChange(newList);
    if (me.props.onCancel) me.props.onCancel(file);
  };

  Uploader.prototype.handleChange = function handleChange(fileList) {
    var me = this;
    me.props.onChange(fileList);
  };

  Uploader.prototype.init = function init() {
    var _this4 = this;

    var me = this;
    me.statchange = function (stat) {
      var total = stat.getTotal();
      if (total !== me.state.total) {
        me.setState({ total: total });
      }
    };
    me.fileuploadstart = function (file) {
      if (file.status === _uploadcore.Status.PROGRESS) {
        me.forceUpdate();
      }
    };
    me.fileuploadsuccess = function (file) {
      var newList = _util2["default"].simpleDeepCopy(me.state.fileList);
      newList.push(Uploader.processFile(file));
      if (me.props.actionOnQueueLimit === 'cover') {
        // the last ones will exist
        var count = 0;
        var coveredList = [];
        for (var i = newList.length - 1; i >= 0; i--) {
          if (count === me.props.queueCapcity) {
            break;
          }
          var item = newList[i];
          if (item.type !== 'delete') {
            count += 1;
          }
          coveredList.push(item);
        }
        newList = coveredList.reverse();
      }
      me.handleChange(newList);
      file.cancel(true);
      me.core.getStat().remove(file);
    };

    me.filecancel = function (file) {
      var onCancel = me.props.onCancel;
      var onfilecancel = me.props.onfilecancel;
      var newList = _util2["default"].simpleDeepCopy(me.state.fileList);
      newList.push({
        type: 'delete',
        response: file.response ? file.response.getJson() : null
      });
      me.handleChange(newList);
      if (onfilecancel) onfilecancel(file);
      if (onCancel) onCancel(Uploader.processFile(file));
    };
    me.core.on(_uploadcore.Events.QUEUE_STAT_CHANGE, me.statchange);
    me.core.on(_uploadcore.Events.FILE_UPLOAD_START, me.fileuploadstart);
    me.core.on(_uploadcore.Events.FILE_UPLOAD_SUCCESS, me.fileuploadsuccess);
    me.core.on(_uploadcore.Events.FILE_CANCEL, me.filecancel);
    me.core.addConstraint(function () {
      var queueCapcity = me.props.queueCapcity;
      var actionOnQueueLimit = me.props.actionOnQueueLimit;
      if (queueCapcity === undefined || queueCapcity === null || queueCapcity <= 0 || actionOnQueueLimit === 'cover') {
        return false;
      }
      return me.state.fileList.filter(function (file) {
        return file.type !== 'delete';
      }).length + me.core.getTotal() >= queueCapcity;
    });
    me.core.addFilter(function (file) {
      if (me.props.preventDuplicate) {
        if (_this4.state.fileList.some(function (item) {
          return item.type === 'upload' && item.name === file.name && item.size === file.size;
        })) {
          return 'DuplicateError: ' + file.name + ' is duplicated';
        }
      }
    });
  };

  Uploader.prototype.renderTips = function renderTips() {
    var _props = this.props,
        tips = _props.tips,
        prefixCls = _props.prefixCls;

    if (tips) {
      return _react2["default"].createElement(
        'div',
        { key: 'tips', className: prefixCls + '-tip' },
        tips
      );
    }
    return null;
  };

  Uploader.prototype.render = function render() {
    var _classNames;

    var me = this;
    var _props2 = this.props,
        prefixCls = _props2.prefixCls,
        locale = _props2.locale,
        className = _props2.className,
        isVisual = _props2.isVisual,
        disabled = _props2.disabled,
        hideUploadIcon = _props2.hideUploadIcon,
        queueCapcity = _props2.queueCapcity;

    var children = this.props.children;
    var readOnly = this.props.readOnly;
    var uploadingFiles = me.getUploadingFiles();
    var notDeletedDefaultFiles = me.getNotDeletedDefaultFiles();
    if (!children || children.length < 1) {
      if (isVisual) {
        children = _react2["default"].createElement(
          'button',
          { className: prefixCls + '-button' },
          _locale2["default"][locale].upload_files_img
        );
      } else {
        children = _react2["default"].createElement(
          _uxcoreButton2["default"],
          { type: 'secondary', size: 'small' },
          _locale2["default"][locale].upload_files
        );
      }
    }
    var tips = readOnly ? null : this.renderTips();
    var noPicker = isVisual && hideUploadIcon && queueCapcity > 0 && uploadingFiles.length + notDeletedDefaultFiles.length >= queueCapcity;
    var picker = readOnly || noPicker ? null : _react2["default"].createElement(
      _Picker2["default"],
      {
        key: 'picker',
        prefixCls: prefixCls,
        core: this.core,
        disabled: disabled,
        isVisual: this.props.isVisual
      },
      children
    );
    var files = uploadingFiles.length > 0 || notDeletedDefaultFiles.length > 0 ? _react2["default"].createElement(
      _FileList2["default"],
      {
        key: 'files',
        prefixCls: prefixCls,
        locale: this.props.locale,
        core: this.core,
        isVisual: this.props.isVisual,
        isOnlyImg: this.props.isOnlyImg,
        readOnly: this.props.readOnly,
        showErrFile: this.props.showErrFile,
        mode: 'nw',
        fileList: me.state.fileList,
        removeFileFromList: me.handleRemoveFile.bind(me),
        interval: this.props.progressInterval,
        onShowFile: this.props.onShowFile && this.props.onShowFile.bind(this),
        onDownloadFile: this.props.onDownloadFile && this.props.onDownloadFile.bind(this)
      },
      isVisual ? picker : null
    ) : isVisual ? picker : null;
    var contents = isVisual ? [tips, files] : [picker, tips, files];

    var clazzName = (0, _classnames2["default"])(className, (_classNames = {}, _defineProperty(_classNames, prefixCls + 'er', true), _defineProperty(_classNames, prefixCls + 'er-disabled', disabled), _classNames));
    return _react2["default"].createElement(
      'div',
      { className: clazzName },
      contents
    );
  };

  return Uploader;
}(_react2["default"].Component);

Uploader.Dropzoom = _Dropzoom2["default"];
Uploader.Events = _uploadcore.Events;
Uploader.Status = _uploadcore.Status;

Uploader.setSWF = function (swf) {
  _uploadcore.UploadCore.setSWF(swf);
};

Uploader.displayName = 'Uploader';
Uploader.defaultProps = {
  prefixCls: 'kuma-upload',
  locale: 'zh-cn',
  autoPending: true,
  fileList: [],
  onChange: function onChange() {},
  onError: function onError() {},
  isVisual: false,
  disabled: false,
  hideUploadIcon: false,
  isOnlyImg: false,
  showErrFile: true
};
Uploader.propTypes = {
  prefixCls: _propTypes2["default"].string,
  locale: _propTypes2["default"].string,
  fileList: _propTypes2["default"].array,
  onShowFile: _propTypes2["default"].func,
  onChange: _propTypes2["default"].func,
  onError: _propTypes2["default"].func,
  tips: _propTypes2["default"].oneOfType([_propTypes2["default"].string, _propTypes2["default"].number, _propTypes2["default"].element]),
  className: _propTypes2["default"].string,
  readOnly: _propTypes2["default"].bool,
  disabled: _propTypes2["default"].bool,
  queueCapcity: _propTypes2["default"].number,
  isVisual: _propTypes2["default"].bool,
  hideUploadIcon: _propTypes2["default"].bool,
  isOnlyImg: _propTypes2["default"].bool,
  showErrFile: _propTypes2["default"].bool,
  children: _propTypes2["default"].any
};


(0, _reactLifecyclesCompat.polyfill)(Uploader);

exports["default"] = Uploader;
module.exports = exports['default'];