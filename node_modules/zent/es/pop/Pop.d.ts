import * as React from 'react';
import { Component } from 'react';
import noop from '../utils/noop';
import Popover, { PositionFunction } from '../popover';
export declare type PopPositions = 'left-top' | 'left-center' | 'left-bottom' | 'right-top' | 'right-center' | 'right-bottom' | 'top-left' | 'top-center' | 'top-right' | 'bottom-left' | 'bottom-center' | 'bottom-right' | 'auto-bottom-center' | 'auto-bottom-left' | 'auto-bottom-right' | 'auto-top-center' | 'auto-top-left' | 'auto-top-right';
export declare type PopActionCallback = ((close: () => void) => void) | (() => Promise<any>);
export declare type PopHookCallback = (callback?: () => void, escape?: () => void) => void;
export interface IPopProps {
    content: React.ReactNode;
    trigger?: 'none' | 'click' | 'hover' | 'focus';
    position?: PopPositions | PositionFunction;
    cushion?: number;
    centerArrow?: boolean;
    header?: React.ReactNode;
    block?: boolean;
    onShow?: () => void;
    onClose?: () => void;
    onBeforeShow?: PopHookCallback;
    onBeforeClose?: PopHookCallback;
    onConfirm?: PopActionCallback;
    onCancel?: PopActionCallback;
    confirmText?: string;
    cancelText?: string;
    type?: 'primary' | 'default' | 'danger' | 'success';
    visible?: boolean;
    onVisibleChange?: (visible: boolean) => void;
    onPositionUpdated?: () => void;
    onPositionReady?: () => void;
    className?: string;
    wrapperClassName?: string;
    containerSelector?: string;
    prefix?: string;
    isOutside?: (target: HTMLElement, node: {
        contentNode: HTMLElement;
        triggerNode: HTMLElement;
    }) => boolean;
    closeOnClickOutside?: boolean;
    quirk?: boolean;
    mouseEnterDelay?: number;
    mouseLeaveDelay?: number;
}
export interface IPopActionProps {
    prefix: string;
    type: 'primary' | 'default' | 'danger' | 'success' | 'secondary';
    onConfirm: PopActionCallback;
    onCancel: PopActionCallback;
    confirmText: string;
    cancelText: string;
    confirmPending: boolean;
    cancelPending: boolean;
    changePending: (key: string, state: boolean, callback?: () => void) => void;
    popover: any;
}
export declare class Pop extends Component<IPopProps> {
    static defaultProps: {
        trigger: string;
        position: string;
        cushion: number;
        centerArrow: boolean;
        block: boolean;
        confirmText: string;
        cancelText: string;
        type: string;
        closeOnClickOutside: boolean;
        mouseLeaveDelay: number;
        mouseEnterDelay: number;
        onPositionUpdated: typeof noop;
        onPositionReady: typeof noop;
        className: string;
        wrapperClassName: string;
        containerSelector: string;
        prefix: string;
        quirk: boolean;
    };
    static withPop: <T extends import("../popover").IPopoverContext>(Base: React.ComponentType<T>) => {
        new (props: Readonly<T>): {
            context: import("../popover").IPopoverContext;
            render(): JSX.Element;
            setState<K extends never>(state: {} | ((prevState: Readonly<{}>, props: Readonly<T>) => {} | Pick<{}, K>) | Pick<{}, K>, callback?: () => void): void;
            forceUpdate(callBack?: () => void): void;
            readonly props: Readonly<T> & Readonly<{
                children?: React.ReactNode;
            }>;
            state: Readonly<{}>;
            refs: {
                [key: string]: React.ReactInstance;
            };
            componentDidMount?(): void;
            shouldComponentUpdate?(nextProps: Readonly<T>, nextState: Readonly<{}>, nextContext: any): boolean;
            componentWillUnmount?(): void;
            componentDidCatch?(error: Error, errorInfo: React.ErrorInfo): void;
            getSnapshotBeforeUpdate?(prevProps: Readonly<T>, prevState: Readonly<{}>): any;
            componentDidUpdate?(prevProps: Readonly<T>, prevState: Readonly<{}>, snapshot?: any): void;
            componentWillMount?(): void;
            UNSAFE_componentWillMount?(): void;
            componentWillReceiveProps?(nextProps: Readonly<T>, nextContext: any): void;
            UNSAFE_componentWillReceiveProps?(nextProps: Readonly<T>, nextContext: any): void;
            componentWillUpdate?(nextProps: Readonly<T>, nextState: Readonly<{}>, nextContext: any): void;
            UNSAFE_componentWillUpdate?(nextProps: Readonly<T>, nextState: Readonly<{}>, nextContext: any): void;
        };
        new (props: T, context?: any): {
            context: import("../popover").IPopoverContext;
            render(): JSX.Element;
            setState<K extends never>(state: {} | ((prevState: Readonly<{}>, props: Readonly<T>) => {} | Pick<{}, K>) | Pick<{}, K>, callback?: () => void): void;
            forceUpdate(callBack?: () => void): void;
            readonly props: Readonly<T> & Readonly<{
                children?: React.ReactNode;
            }>;
            state: Readonly<{}>;
            refs: {
                [key: string]: React.ReactInstance;
            };
            componentDidMount?(): void;
            shouldComponentUpdate?(nextProps: Readonly<T>, nextState: Readonly<{}>, nextContext: any): boolean;
            componentWillUnmount?(): void;
            componentDidCatch?(error: Error, errorInfo: React.ErrorInfo): void;
            getSnapshotBeforeUpdate?(prevProps: Readonly<T>, prevState: Readonly<{}>): any;
            componentDidUpdate?(prevProps: Readonly<T>, prevState: Readonly<{}>, snapshot?: any): void;
            componentWillMount?(): void;
            UNSAFE_componentWillMount?(): void;
            componentWillReceiveProps?(nextProps: Readonly<T>, nextContext: any): void;
            UNSAFE_componentWillReceiveProps?(nextProps: Readonly<T>, nextContext: any): void;
            componentWillUpdate?(nextProps: Readonly<T>, nextState: Readonly<{}>, nextContext: any): void;
            UNSAFE_componentWillUpdate?(nextProps: Readonly<T>, nextState: Readonly<{}>, nextContext: any): void;
        };
        contextType: React.Context<import("../popover").IPopoverContext>;
    };
    popover: Popover;
    isUnmounted: boolean;
    state: {
        confirmPending: boolean;
        cancelPending: boolean;
    };
    changePending: (key: any, pending: any, callback: any) => void;
    renderContent(): JSX.Element;
    renderTrigger(): JSX.Element;
    componentWillUnmount(): void;
    render(): JSX.Element;
    onPopoverRefChange: (popoverInstance: any) => void;
    adjustPosition(): void;
    getWrappedPopover(): Popover;
}
export default Pop;
