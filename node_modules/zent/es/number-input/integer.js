var warning = require('warning');
function withinRange(min, max, num) {
    if (min >= num) {
        return min;
    }
    if (max <= num) {
        return max;
    }
    return num;
}
function getMax(max) {
    return typeof max === 'number' && !Number.isNaN(max)
        ? withinRange(Number.MIN_SAFE_INTEGER, Number.MAX_SAFE_INTEGER, max)
        : Number.MAX_SAFE_INTEGER;
}
function getMin(min) {
    return typeof min === 'number' && !Number.isNaN(min)
        ? withinRange(Number.MIN_SAFE_INTEGER, Number.MAX_SAFE_INTEGER, min)
        : Number.MIN_SAFE_INTEGER;
}
export function normalizeMinMax(props) {
    var max = getMax(props.max);
    var min = getMin(props.min);
    if (min > max) {
        warning(false, 'max is smaller than min');
        return {
            min: max,
            max: min,
        };
    }
    return {
        min: min,
        max: max,
    };
}
export function isPotentialValue(value) {
    return value === '' || value === '-' || value === '+';
}
export function isInteger(value) {
    return /^[\-+]?\d*$/.test(value);
}
export function normalizeValue(potential, min, max) {
    var value;
    var input = null;
    if (potential === null || potential === undefined) {
        value = null;
        input = '';
    }
    else if (typeof potential === 'string') {
        value = parseInt(potential, 10) || 0;
    }
    else if (Number.isNaN(potential)) {
        value = 0;
        input = '';
    }
    else {
        value = Math.floor(potential);
    }
    if (value !== null) {
        value = Math.min(max, value);
        value = Math.max(min, value);
    }
    if (input === null) {
        input = String(value);
    }
    return {
        value: value,
        input: input,
    };
}
export function calculateLimit(value, min, max) {
    if (value === null) {
        return {
            canDec: false,
            canInc: false,
        };
    }
    var canDec = true;
    var canInc = true;
    if (min >= value) {
        canDec = false;
    }
    if (max <= value) {
        canInc = false;
    }
    return {
        canDec: canDec,
        canInc: canInc,
    };
}
