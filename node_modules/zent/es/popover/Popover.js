import { __assign, __extends } from "tslib";
import * as React from 'react';
import { Component, Children } from 'react';
import * as ReactDOM from 'react-dom';
import cx from 'classnames';
import uniqueId from '../utils/uniqueId';
import noop from '../utils/noop';
import isPromise from '../utils/isPromise';
import kindOf from '../utils/kindOf';
import getWidth from '../utils/getWidth';
import memoize from '../utils/memorize-one';
import PopoverContent from './Content';
import Trigger from './trigger';
import PopoverTrigger from './trigger/Trigger';
import PopoverContext from './PopoverContext';
import withPopover from './withPopover';
import Position from './placement';
var SKIPPED = function () { };
function handleBeforeHook(beforeFn, arity, continuation, escape) {
    if (arity === 1) {
        return beforeFn(continuation);
    }
    if (arity >= 2) {
        return beforeFn(continuation, escape);
    }
    var mayBePromise = beforeFn();
    if (!isPromise(mayBePromise) && mayBePromise !== SKIPPED) {
        return continuation();
    }
    mayBePromise.then(continuation, escape);
}
var Popover = (function (_super) {
    __extends(Popover, _super);
    function Popover(props) {
        var _this = _super.call(this, props) || this;
        _this.registerDescendant = function (popover) {
            _this.descendants.push(popover);
        };
        _this.unregisterDescendant = function (popover) {
            var idx = _this.descendants.indexOf(popover);
            _this.descendants.splice(idx, 1);
        };
        _this.getPopoverContext = memoize(function () {
            return {
                _zentPopover: {
                    close: _this.close,
                    open: _this.open,
                    getContentNode: _this.getPopoverNode,
                    getTriggerNode: _this.getTriggerNode,
                    registerDescendant: _this.registerDescendant,
                    unregisterDescendant: _this.unregisterDescendant,
                },
            };
        });
        _this.getVisible = function (props, state) {
            if (_this.isVisibilityControlled(props)) {
                props = props || _this.props;
                return props.visible;
            }
            state = state || _this.state;
            return state.visible;
        };
        _this.setVisible = function (visible, props, state) {
            props = props || _this.props;
            state = state || _this.state;
            var beforeHook = visible ? props.onBeforeShow : props.onBeforeClose;
            var onBefore = function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                if (_this.pendingOnBeforeHook) {
                    return SKIPPED;
                }
                _this.pendingOnBeforeHook = true;
                return beforeHook.apply(void 0, args);
            };
            var escapse = function () {
                _this.pendingOnBeforeHook = false;
            };
            if (_this.isVisibilityControlled(props)) {
                if (_this.pendingOnBeforeHook || props.visible === visible) {
                    return;
                }
                handleBeforeHook(onBefore, beforeHook.length, function () {
                    props.onVisibleChange(visible);
                    _this.pendingOnBeforeHook = false;
                }, escapse);
            }
            else {
                if (_this.pendingOnBeforeHook || state.visible === visible) {
                    return;
                }
                handleBeforeHook(onBefore, beforeHook.length, function () {
                    _this.safeSetState({ visible: visible });
                    _this.pendingOnBeforeHook = false;
                }, escapse);
            }
        };
        _this.getPopoverNode = function () {
            return document.querySelector("." + _this.id);
        };
        _this.onTriggerRefChange = function (triggerInstance, nodeFilter) {
            var node = triggerInstance
                ? ReactDOM.findDOMNode(triggerInstance)
                : undefined;
            _this.triggerNode =
                typeof nodeFilter === 'function' ? nodeFilter(node) : node;
            _this.triggerInstance = triggerInstance;
        };
        _this.onContentRefChange = function (contentInstance) {
            _this.contentInstance = contentInstance;
        };
        _this.getTriggerNode = function () {
            return _this.triggerNode;
        };
        _this.onPositionUpdated = function () {
            _this.descendants.forEach(function (child) {
                child.adjustPosition();
            });
            var onPositionUpdated = _this.props.onPositionUpdated;
            if (onPositionUpdated) {
                onPositionUpdated();
            }
        };
        _this.open = function () {
            _this.setVisible(true);
        };
        _this.close = function () {
            _this.setVisible(false);
        };
        _this.injectIsOutsideSelf = function (impl) {
            _this.isOutsideSelf = impl;
        };
        _this.isOutsideStacked = function (node) {
            if (_this.isOutsideSelf) {
                if (!_this.isOutsideSelf(node)) {
                    return false;
                }
            }
            if (_this.descendants.some(function (popover) { return !popover.isOutsideStacked(node); })) {
                return false;
            }
            return true;
        };
        _this.id = uniqueId(props.prefix + "-popover-internal-id-");
        _this.descendants = [];
        if (!_this.isVisibilityControlled(props)) {
            _this.state = {
                visible: false,
            };
        }
        _this.isUnmounted = false;
        return _this;
    }
    Popover.prototype.isVisibilityControlled = function (props) {
        var _a = props || this.props, visible = _a.visible, onVisibleChange = _a.onVisibleChange;
        var hasOnChange = typeof onVisibleChange === 'function';
        var hasVisible = typeof visible === 'boolean';
        if ((hasVisible && !hasOnChange) || (hasOnChange && !hasVisible)) {
            throw new Error('visible and onVisibleChange must be used together');
        }
        return hasVisible && hasOnChange;
    };
    Popover.prototype.adjustPosition = function () {
        if (this.contentInstance && this.contentInstance.adjustPosition) {
            this.contentInstance.adjustPosition();
        }
    };
    Popover.prototype.validateChildren = function () {
        var children = this.props.children;
        var childArray = Children.toArray(children);
        if (childArray.length !== 2) {
            throw new Error('There must be one and only one trigger and content in Popover');
        }
        var _a = childArray.reduce(function (state, c) {
            var type = c.type;
            if (kindOf(type, PopoverTrigger)) {
                state.trigger = c;
            }
            else if (kindOf(type, PopoverContent)) {
                state.content = c;
            }
            return state;
        }, { trigger: null, content: null }), trigger = _a.trigger, content = _a.content;
        if (!trigger) {
            throw new Error('Missing trigger in Popover');
        }
        if (!content) {
            throw new Error('Missing content in Popover');
        }
        return { trigger: trigger, content: content };
    };
    Popover.prototype.safeSetState = function (updater, callback) {
        if (!this.isUnmounted) {
            return this.setState(updater, callback);
        }
    };
    Popover.prototype.componentDidMount = function () {
        var popover = (this.context || {})._zentPopover;
        if (popover && popover.registerDescendant) {
            popover.registerDescendant(this);
        }
        if (this.isVisibilityControlled() && this.props.visible) {
            this.props.onShow();
        }
    };
    Popover.prototype.componentDidUpdate = function (prevProps, prevState) {
        var visible = this.getVisible();
        if (visible !== this.getVisible(prevProps, prevState)) {
            var afterHook = visible ? this.props.onShow : this.props.onClose;
            afterHook();
        }
    };
    Popover.prototype.componentWillUnmount = function () {
        var popover = (this.context || {})._zentPopover;
        if (popover && popover.unregisterDescendant) {
            popover.unregisterDescendant(this);
        }
        this.isUnmounted = true;
    };
    Popover.prototype.render = function () {
        var _a = this.validateChildren(), trigger = _a.trigger, content = _a.content;
        var _b = this.props, display = _b.display, prefix = _b.prefix, className = _b.className, wrapperClassName = _b.wrapperClassName, containerSelector = _b.containerSelector, position = _b.position, cushion = _b.cushion, width = _b.width, onPositionReady = _b.onPositionReady;
        var visible = this.getVisible();
        return (React.createElement("div", { style: __assign({ display: display }, getWidth(width)), className: cx(prefix + "-popover-wrapper", wrapperClassName), "data-zv": '7.4.3' },
            React.createElement(PopoverContext.Provider, { value: this.getPopoverContext() },
                React.cloneElement(trigger, {
                    prefix: prefix,
                    contentVisible: visible,
                    onTriggerRefChange: this.onTriggerRefChange,
                    getTriggerNode: this.getTriggerNode,
                    getContentNode: this.getPopoverNode,
                    open: this.open,
                    close: this.close,
                    isOutsideStacked: this.isOutsideStacked,
                    injectIsOutsideSelf: this.injectIsOutsideSelf,
                }),
                React.cloneElement(content, {
                    prefix: prefix,
                    className: className,
                    id: this.id,
                    getContentNode: this.getPopoverNode,
                    getAnchor: this.getTriggerNode,
                    ref: this.onContentRefChange,
                    visible: visible,
                    cushion: cushion,
                    containerSelector: containerSelector,
                    placement: position,
                    onPositionUpdated: this.onPositionUpdated,
                    onPositionReady: onPositionReady,
                }))));
    };
    Popover.defaultProps = {
        prefix: 'zent',
        className: '',
        wrapperClassName: '',
        display: 'block',
        onBeforeClose: noop,
        onBeforeShow: noop,
        onClose: noop,
        onShow: noop,
        cushion: 0,
        containerSelector: 'body',
        onPositionUpdated: noop,
        onPositionReady: noop,
    };
    Popover.contextType = PopoverContext;
    Popover.Content = PopoverContent;
    Popover.Trigger = Trigger;
    Popover.Position = Position;
    Popover.withPopover = withPopover;
    return Popover;
}(Component));
export { Popover };
export default Popover;
