import { __assign, __extends } from "tslib";
import 'react';
import throttle from '../../utils/throttle';
import uniq from '../../utils/uniq';
import capitalize from '../../utils/capitalize';
import isBrowser from '../../utils/isBrowser';
import Trigger from './Trigger';
var MOUSE_EVENT_WHITE_LIST = [
    'down',
    'up',
    'move',
    'over',
    'out',
    'enter',
    'leave',
];
function isMouseEventSuffix(suffix) {
    return MOUSE_EVENT_WHITE_LIST.indexOf(suffix) !== -1;
}
var HoverState = {
    Init: 1,
    Started: 2,
    Pending: 3,
    Finish: 255,
};
var makeState = function (name, onFinish, initState) {
    if (initState === void 0) { initState = HoverState.Init; }
    var state = initState;
    return {
        transit: function (nextState) {
            state = nextState;
            if (state === HoverState.Finish) {
                onFinish();
            }
        },
        is: function (st) {
            return st === state;
        },
        name: name,
    };
};
function forEachHook(hooks, action) {
    if (!hooks) {
        return;
    }
    if (!isBrowser)
        return;
    var hookNames = Object.keys(hooks);
    hookNames.forEach(function (hookName) {
        var eventName = isMouseEventSuffix(hookName)
            ? "mouse" + hookName
            : hookName;
        if (action === 'install') {
            window.addEventListener(eventName, hooks[hookName], true);
        }
        else if (action === 'uninstall') {
            window.removeEventListener(eventName, hooks[hookName], true);
        }
    });
}
function makeRecognizer(state, options) {
    var recognizer = __assign(__assign({}, options), { destroy: function () {
            if (!state.is(HoverState.Finish)) {
                forEachHook(recognizer.global, 'uninstall');
            }
        } });
    forEachHook(recognizer.global, 'install');
    return recognizer;
}
function makeHoverEnterRecognizer(_a) {
    var enterDelay = _a.enterDelay, onEnter = _a.onEnter;
    var state = makeState('enter', onEnter);
    var timerId;
    var recognizer = makeRecognizer(state, {
        local: {
            enter: function () {
                state.transit(HoverState.Pending);
                timerId = setTimeout(function () {
                    state.transit(HoverState.Finish);
                    forEachHook(recognizer.global, 'uninstall');
                }, enterDelay);
            },
            leave: function () {
                if (timerId) {
                    clearTimeout(timerId);
                    timerId = undefined;
                    state.transit(HoverState.Init);
                }
            },
        },
    });
    return recognizer;
}
function makeHoverLeaveRecognizer(_a) {
    var leaveDelay = _a.leaveDelay, onLeave = _a.onLeave, isOutSide = _a.isOutSide, quirk = _a.quirk;
    var state = makeState('leave', onLeave);
    var recognizer;
    var timerId;
    var gotoFinishState = function () {
        state.transit(HoverState.Finish);
        forEachHook(recognizer.global, 'uninstall');
    };
    recognizer = makeRecognizer(state, {
        global: {
            move: throttle(function (evt) {
                var target = evt.target;
                if (isOutSide(target)) {
                    if (!quirk && !state.is(HoverState.Started)) {
                        return;
                    }
                    state.transit(HoverState.Pending);
                    timerId = setTimeout(gotoFinishState, leaveDelay);
                }
                else {
                    if (state.is(HoverState.Init)) {
                        state.transit(HoverState.Started);
                        return;
                    }
                    if (!state.is(HoverState.Pending)) {
                        return;
                    }
                    if (timerId) {
                        clearTimeout(timerId);
                        timerId = undefined;
                        state.transit(HoverState.Started);
                    }
                }
            }, 16),
            blur: function (evt) {
                var target = evt.target || evt.srcElement;
                if (target !== window) {
                    return;
                }
                if (timerId) {
                    clearTimeout(timerId);
                    timerId = undefined;
                }
                gotoFinishState();
            },
        },
    });
    return recognizer;
}
function callHook(recognizer, namespace, hookName) {
    var args = [];
    for (var _i = 3; _i < arguments.length; _i++) {
        args[_i - 3] = arguments[_i];
    }
    var ns = recognizer && recognizer[namespace];
    if (ns && ns[hookName])
        ns[hookName].apply(ns, args);
}
function destroyRecognizer(recognizer) {
    if (recognizer) {
        recognizer.destroy();
    }
}
var PopoverHoverTrigger = (function (_super) {
    __extends(PopoverHoverTrigger, _super);
    function PopoverHoverTrigger() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.open = function () {
            _this.props.open();
        };
        _this.close = function () {
            _this.props.close();
        };
        _this.state = {
            enterRecognizer: null,
            leaveRecognizer: null,
        };
        return _this;
    }
    PopoverHoverTrigger.prototype.makeEnterRecognizer = function () {
        var showDelay = this.props.showDelay;
        return makeHoverEnterRecognizer({
            enterDelay: showDelay,
            onEnter: this.open,
        });
    };
    PopoverHoverTrigger.prototype.makeLeaveRecognizer = function () {
        var _a = this.props, quirk = _a.quirk, hideDelay = _a.hideDelay, isOutsideStacked = _a.isOutsideStacked;
        return makeHoverLeaveRecognizer({
            leaveDelay: hideDelay,
            onLeave: this.close,
            isOutSide: isOutsideStacked,
            quirk: quirk,
        });
    };
    PopoverHoverTrigger.prototype.getTriggerProps = function (child) {
        var _this = this;
        var _a = this.state, enterRecognizer = _a.enterRecognizer, leaveRecognizer = _a.leaveRecognizer;
        var enterHooks = (enterRecognizer && enterRecognizer.local) || {};
        var leaveHooks = (leaveRecognizer && leaveRecognizer.local) || {};
        var eventNames = uniq([].concat(Object.keys(enterHooks), Object.keys(leaveHooks))).map(function (name) { return "onMouse" + capitalize(name); });
        var eventNameToHookName = function (eventName) {
            return eventName.slice('onMouse'.length).toLowerCase();
        };
        return eventNames.reduce(function (events, evtName) {
            var hookName = eventNameToHookName(evtName);
            events[evtName] = function (evt) {
                callHook(enterRecognizer, 'local', hookName);
                callHook(leaveRecognizer, 'local', hookName);
                _this.triggerEvent(child, evtName, evt);
            };
            return events;
        }, {});
    };
    PopoverHoverTrigger.prototype.cleanup = function () {
        destroyRecognizer(this.state.enterRecognizer);
        destroyRecognizer(this.state.leaveRecognizer);
    };
    PopoverHoverTrigger.prototype.initRecognizers = function (props) {
        props = props || this.props;
        var contentVisible = props.contentVisible;
        this.cleanup();
        this.setState({
            enterRecognizer: contentVisible ? null : this.makeEnterRecognizer(),
            leaveRecognizer: contentVisible ? this.makeLeaveRecognizer() : null,
        });
    };
    PopoverHoverTrigger.prototype.componentWillUnmount = function () {
        this.cleanup();
    };
    PopoverHoverTrigger.prototype.componentDidMount = function () {
        this.initRecognizers();
    };
    PopoverHoverTrigger.prototype.componentWillReceiveProps = function (nextProps) {
        var contentVisible = nextProps.contentVisible;
        if (contentVisible !== this.props.contentVisible) {
            this.initRecognizers(nextProps);
        }
    };
    PopoverHoverTrigger.defaultProps = {
        showDelay: 150,
        hideDelay: 150,
        quirk: false,
    };
    return PopoverHoverTrigger;
}(Trigger));
export default PopoverHoverTrigger;
