'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _classnames = require('classnames');

var _classnames2 = _interopRequireDefault(_classnames);

var _objectAssign = require('object-assign');

var _objectAssign2 = _interopRequireDefault(_objectAssign);

var _propTypes = require('prop-types');

var _propTypes2 = _interopRequireDefault(_propTypes);

var _SplitBar = require('./SplitBar');

var _SplitBar2 = _interopRequireDefault(_SplitBar);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); } /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Splitter Component for uxcore
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @author vincent.bian
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Copyright 2015-2016, Uxcore Team, Alinw.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * All rights reserved.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */


function clearSelection() {
  if (window.getSelection) {
    if (window.getSelection().empty) {
      window.getSelection().empty();
    } else if (window.getSelection().removeAllRanges) {
      window.getSelection().removeAllRanges();
    }
  } else if (document.selection) {
    document.selection.empty();
  }
}

var Splitter = function (_React$Component) {
  _inherits(Splitter, _React$Component);

  function Splitter(props) {
    _classCallCheck(this, Splitter);

    var _this = _possibleConstructorReturn(this, _React$Component.call(this, props));

    _this.state = {
      paneOffset: [],
      resizeBar: null,
      resizeBarIndex: 0,
      autoSizePaneSize: null
    };
    _this.paneList = [];
    _this.resizeOriginPos = null;
    _this.delta = 0;
    _this.handleMouseMove = _this.handleMouseMove.bind(_this);
    _this.handleMouseUp = _this.handleMouseUp.bind(_this);
    _this.autoSizePaneSize = 0;
    return _this;
  }

  // eslint-disable-line


  Splitter.prototype.componentDidMount = function componentDidMount() {
    this.calculatePaneOffset();
  };

  Splitter.prototype.calculatePaneOffset = function calculatePaneOffset() {
    var _this2 = this;

    var paneOffset = [];
    var offset = void 0;var prevOffset = void 0;
    var sizeAry = this.paneList.map(function (pane, i) {
      return _this2.paneList[i].getCurrentSize();
    }).map(function (size) {
      return size === 'collapsed' ? 0 : size;
    });
    var autoSizePaneIndex = false;
    var leftAlignPaneAry = [];
    var rightAlignPaneAry = [];
    sizeAry.forEach(function (size, i) {
      if (typeof size !== 'number') {
        if (autoSizePaneIndex !== false) {
          console.warn('uxcore-splitter: the splitter has more than one pane which is auto sized.');
        }
        autoSizePaneIndex = i;
      } else if (autoSizePaneIndex !== false) {
        rightAlignPaneAry.push(size);
      } else {
        leftAlignPaneAry.push(size);
      }
    });
    leftAlignPaneAry = leftAlignPaneAry.reduce(function (prev, size, index) {
      if (index === 0) {
        prev.push({
          start: 0,
          size: size,
          align: 'left'
        });
      } else {
        prev.push({
          start: prev[index - 1].start + prev[index - 1].size,
          size: size,
          align: 'left'
        });
      }
      return prev;
    }, []);
    rightAlignPaneAry = rightAlignPaneAry.reverse().reduce(function (prev, size, index) {
      if (index === 0) {
        prev.unshift({
          end: 0,
          size: size,
          align: 'right'
        });
      } else {
        prev.unshift({
          end: prev[0].end + prev[0].size,
          size: size,
          align: 'right'
        });
      }
      return prev;
    }, []);
    paneOffset = paneOffset.concat(leftAlignPaneAry);
    if (autoSizePaneIndex !== false) {
      var middlePane = {
        start: 0,
        end: 0,
        align: 'none'
      };
      if (leftAlignPaneAry.length > 0) {
        middlePane.start = leftAlignPaneAry[leftAlignPaneAry.length - 1].start + leftAlignPaneAry[leftAlignPaneAry.length - 1].size;
      }
      if (rightAlignPaneAry.length > 0) {
        middlePane.end = rightAlignPaneAry[0].end + rightAlignPaneAry[0].size;
      }
      paneOffset.push(middlePane);
    }
    paneOffset = paneOffset.concat(rightAlignPaneAry);
    this.setState({
      paneOffset: paneOffset,
      autoSizePaneIndex: autoSizePaneIndex
    }, function () {
      _this2.setAutoSizePane();
    });
  };

  Splitter.prototype.setAutoSizePane = function setAutoSizePane() {
    var autoSizePaneIndex = this.state.autoSizePaneIndex;
    var orientation = this.props.orientation;

    if (typeof autoSizePaneIndex === 'number') {
      if (this.props.orientation === 'vertical') {
        this.autoSizePaneSize = this.paneList[autoSizePaneIndex].pane.clientWidth;
      } else {
        this.autoSizePaneSize = this.paneList[autoSizePaneIndex].pane.clientHeight;
      }
    }
  };

  Splitter.prototype.handleMouseMove = function handleMouseMove(e) {
    var orientation = this.props.orientation;
    var _state = this.state,
        resizeBar = _state.resizeBar,
        resizeBarIndex = _state.resizeBarIndex,
        paneOffset = _state.paneOffset;

    var nextPaneSize = void 0;var prevPaneSize = void 0;
    if (resizeBar) {
      var delta = void 0;
      switch (orientation) {
        case 'vertical':
          delta = e.clientX - this.resizeOriginPos.x;
          break;
        case 'horizontal':
        default:
          delta = e.clientY - this.resizeOriginPos.y;
          break;
      }
      // 边界处理
      if (delta > 0) {
        if (paneOffset[resizeBarIndex].align !== 'none') {
          nextPaneSize = paneOffset[resizeBarIndex].size;
          delta = delta > nextPaneSize ? nextPaneSize : delta;
        } else {
          delta = delta > this.autoSizePaneSize ? this.autoSizePaneSize : delta;
        }
      } else if (paneOffset[resizeBarIndex - 1].align !== 'none') {
        prevPaneSize = paneOffset[resizeBarIndex - 1].size;
        delta = Math.abs(delta) > prevPaneSize ? -prevPaneSize : delta;
      } else {
        delta = Math.abs(delta) > this.autoSizePaneSize ? -this.autoSizePaneSize : delta;
      }
      // console.log('handleMouseMove', delta, paneOffset[resizeBarIndex - 1], paneOffset[resizeBarIndex]);
      resizeBar.move(delta);
      this.delta = delta;
      clearSelection();
    }
  };

  Splitter.prototype.handleMouseUp = function handleMouseUp() {
    var _this3 = this;

    var _state2 = this.state,
        resizeBar = _state2.resizeBar,
        resizeBarIndex = _state2.resizeBarIndex;
    var paneOffset = this.state.paneOffset;

    if (resizeBar) {
      if (paneOffset[resizeBarIndex - 1].align !== 'none') {
        paneOffset[resizeBarIndex - 1].size += this.delta;
        if (paneOffset[resizeBarIndex].align === 'left') {
          paneOffset[resizeBarIndex].start += this.delta;
          paneOffset[resizeBarIndex].size -= this.delta;
        } else if (paneOffset[resizeBarIndex].align === 'right') {
          paneOffset[resizeBarIndex - 1].end -= this.delta;
          paneOffset[resizeBarIndex].size -= this.delta;
        } else {
          paneOffset[resizeBarIndex].start += this.delta;
        }
      } else {
        paneOffset[resizeBarIndex - 1].end -= this.delta;
        paneOffset[resizeBarIndex].size -= this.delta;
      }
      resizeBar.stopResizing();
      this.props.onResize(paneOffset, resizeBar, resizeBarIndex - 1);
      this.setState({
        resizing: false,
        resizeBar: null,
        resizeBarIndex: 0,
        paneOffset: paneOffset
      }, function () {
        _this3.setAutoSizePane();
      });
    }
  };

  Splitter.prototype.handleTogglePane = function handleTogglePane(i) {
    this.calculatePaneOffset();
  };

  Splitter.prototype.render = function render() {
    var _props = this.props,
        prefixCls = _props.prefixCls,
        className = _props.className,
        orientation = _props.orientation;

    return _react2["default"].createElement(
      'div',
      {
        onMouseMove: this.handleMouseMove,
        onMouseUp: this.handleMouseUp,
        className: (0, _classnames2["default"])(prefixCls, prefixCls + '-' + orientation, className)
      },
      this.renderPanes()
    );
  };

  Splitter.prototype.renderPanes = function renderPanes() {
    var _this4 = this;

    var _props2 = this.props,
        prefixCls = _props2.prefixCls,
        children = _props2.children,
        orientation = _props2.orientation;
    var paneOffset = this.state.paneOffset;

    var panes = [];
    var paneProps = void 0;var prevPaneSize = void 0;var curPaneSize = void 0;var disable = void 0;var hide = void 0;
    var paneSizes = this.paneList.map(function (pane) {
      return pane.getCurrentSize();
    });
    _react2["default"].Children.forEach(children, function (Comp, i) {
      if (i !== 0) {
        if (paneSizes.length > 0) {
          prevPaneSize = paneSizes[i - 1];
          curPaneSize = paneSizes[i];
          hide = curPaneSize === 'collapsed';
          disable = !_this4.paneList[i - 1].props.resizable || prevPaneSize === 'collapsed';
          if (prevPaneSize === 'collapsed' && i === 1) {
            hide = true;
          }
          // console.log(i, /*disable, hide,*/ prevPaneSize, curPaneSize);
          panes.push(_react2["default"].createElement(_SplitBar2["default"], {
            orientation: orientation,
            prevPaneOffset: paneOffset[i - 1],
            nextPaneOffset: paneOffset[i],
            className: (0, _classnames2["default"])(prefixCls + '-split-bar', '' + orientation),
            key: 'bar-' + (i - 1),
            onResizeActive: function onResizeActive(bar, position) {
              _this4.setState({
                resizeBar: bar,
                resizeBarIndex: i
              });
              _this4.resizeOriginPos = position;
            },
            disable: disable,
            hide: hide
          }));
        }
      }
      paneProps = {
        prefixCls: prefixCls,
        orientation: orientation,
        className: (0, _classnames2["default"])(prefixCls + '-pane', prefixCls + '-pane-' + orientation),
        ref: function ref(pane) {
          return _this4.paneList[i] = pane;
        },
        key: 'pane-' + i,
        onTogglePane: function onTogglePane() {
          _this4.handleTogglePane(i);
        },
        parentSplitter: _this4
      };
      if (paneOffset[i]) {
        (0, _objectAssign2["default"])(paneProps, {
          offset: paneOffset[i]
        });
      }
      panes.push(_react2["default"].cloneElement(Comp, paneProps));
    });
    return panes;
  };

  return Splitter;
}(_react2["default"].Component);

Splitter.displayName = 'Splitter';
Splitter.propTypes = {
  prefixCls: _propTypes2["default"].string,
  orientation: _propTypes2["default"].oneOf(['vertical', 'horizontal']),
  className: _propTypes2["default"].string,
  onResize: _propTypes2["default"].func };
Splitter.defaultProps = {
  prefixCls: 'uxcore-splitter',
  orientation: 'horizontal',
  className: '',
  onResize: function onResize(offsets, pane, index) {
    console.log(offsets, pane, index);
  }
};
exports["default"] = Splitter;
module.exports = exports['default'];