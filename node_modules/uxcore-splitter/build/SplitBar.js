'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _classnames = require('classnames');

var _classnames2 = _interopRequireDefault(_classnames);

var _objectAssign = require('object-assign');

var _objectAssign2 = _interopRequireDefault(_objectAssign);

var _propTypes = require('prop-types');

var _propTypes2 = _interopRequireDefault(_propTypes);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); } /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Splitter Component for uxcore
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @author vincent.bian
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Copyright 2015-2016, Uxcore Team, Alinw.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * All rights reserved.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */


var NonObjectProps = ['className', 'disable', 'hide', 'orientation', 'resizable'];
var OffsetProps = ['prevPaneOffset', 'nextPaneOffset'];

var SplitBar = function (_React$Component) {
  _inherits(SplitBar, _React$Component);

  function SplitBar(props) {
    _classCallCheck(this, SplitBar);

    var _this = _possibleConstructorReturn(this, _React$Component.call(this, props));

    _this.state = {
      resizing: false,
      ghostPosition: null
    };
    _this.handleSplitMouseDown = _this.handleSplitMouseDown.bind(_this);
    return _this;
  }

  // eslint-disable-line


  SplitBar.prototype.shouldComponentUpdate = function shouldComponentUpdate(nextProps, nextState) {
    var _this2 = this;

    if (nextState.ghostPosition !== this.state.ghostPosition || nextState.resizing !== this.state.resizing) {
      return true;
    }
    if (NonObjectProps.some(function (propName) {
      return nextProps[propName] !== _this2.props[propName];
    })) {
      return true;
    }
    if (OffsetProps.some(function (name) {
      return !(nextProps[name].align === _this2.props[name].align && nextProps[name].start === _this2.props[name].start && nextProps[name].end === _this2.props[name].end && nextProps[name].size === _this2.props[name].size);
    })) {
      return true;
    }
    return false;
  };

  SplitBar.prototype.stopResizing = function stopResizing() {
    this.setState({
      resizing: false,
      ghostPosition: null
    });
  };

  SplitBar.prototype.handleSplitMouseDown = function handleSplitMouseDown(e) {
    this.setState({
      resizing: true
    });
    this.props.onResizeActive(this, {
      x: e.clientX,
      y: e.clientY
    });
  };

  SplitBar.prototype.move = function move(pos) {
    this.setState({
      ghostPosition: pos
    });
  };

  SplitBar.prototype.render = function render() {
    var _props = this.props,
        className = _props.className,
        orientation = _props.orientation,
        prevPaneOffset = _props.prevPaneOffset,
        nextPaneOffset = _props.nextPaneOffset,
        disable = _props.disable,
        hide = _props.hide;
    var _state = this.state,
        resizing = _state.resizing,
        ghostPosition = _state.ghostPosition;

    var barStyle = {};
    var ghostBarStyle = {};
    switch (orientation) {
      case 'vertical':
        if (prevPaneOffset.align === 'left') {
          (0, _objectAssign2["default"])(barStyle, {
            left: prevPaneOffset.size + prevPaneOffset.start
          });
        } else if (prevPaneOffset.align === 'right' || prevPaneOffset.align === 'none') {
          (0, _objectAssign2["default"])(barStyle, {
            right: nextPaneOffset.size + nextPaneOffset.end
          });
        }
        (0, _objectAssign2["default"])(barStyle, {
          width: 1,
          height: '100%'
        });
        if (resizing && ghostPosition) {
          (0, _objectAssign2["default"])(ghostBarStyle, {
            left: ghostPosition
          });
        }
        break;
      case 'horizontal':
      default:
        if (prevPaneOffset.align === 'left') {
          (0, _objectAssign2["default"])(barStyle, {
            top: prevPaneOffset.size + prevPaneOffset.start
          });
        } else if (prevPaneOffset.align === 'right' || prevPaneOffset.align === 'none') {
          (0, _objectAssign2["default"])(barStyle, {
            bottom: nextPaneOffset.size + nextPaneOffset.end
          });
        }
        (0, _objectAssign2["default"])(barStyle, {
          width: '100%',
          height: 1
        });
        if (resizing && ghostPosition) {
          (0, _objectAssign2["default"])(ghostBarStyle, {
            top: ghostPosition
          });
        }
        break;
    }
    var barProps = {
      className: (0, _classnames2["default"])(className, {
        'split-bar-hide': hide,
        'resize-bar': !disable
      }),
      style: barStyle
    };
    if (!disable) {
      (0, _objectAssign2["default"])(barProps, {
        onMouseDown: this.handleSplitMouseDown
      });
    }
    return _react2["default"].createElement(
      'div',
      barProps,
      resizing ? _react2["default"].createElement('div', { className: 'ghost-split-bar', style: ghostBarStyle }) : null
    );
  };

  return SplitBar;
}(_react2["default"].Component);

SplitBar.displayName = 'SplitBar';
SplitBar.propTypes = {
  className: _propTypes2["default"].string,
  resizable: _propTypes2["default"].bool,
  orientation: _propTypes2["default"].oneOf(['vertical', 'horizontal']),
  prevPaneOffset: _propTypes2["default"].object,
  nextPaneOffset: _propTypes2["default"].object,
  onResizeActive: _propTypes2["default"].func,
  disable: _propTypes2["default"].bool,
  hide: _propTypes2["default"].bool };
SplitBar.defaultProps = {
  className: '',
  resizable: false,
  orientation: 'horizontal',
  prevPaneOffset: 0,
  nextPaneOffset: 0,
  onResizeActive: function onResizeActive() {},
  disable: false,
  hide: false
};
exports["default"] = SplitBar;
module.exports = exports['default'];