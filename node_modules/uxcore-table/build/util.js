'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _uxcoreFormatter = require('uxcore-formatter');

var _uxcoreFormatter2 = _interopRequireDefault(_uxcoreFormatter);

var _cloneDeep = require('lodash/cloneDeep');

var _cloneDeep2 = _interopRequireDefault(_cloneDeep);

var _cssAnimation = require('css-animation');

var _cssAnimation2 = _interopRequireDefault(_cssAnimation);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

var scrollbarWidth = void 0;

// Measure scrollbar width for padding body during modal show/hide
var scrollbarMeasure = {
  position: 'absolute',
  top: '-9999px',
  width: '50px',
  height: '50px',
  overflow: 'scroll'
};

/**
 * Get IE version.
 * @return {number} the IE version, 0 if the browser is not IE.
 */
var getIEVer = function getIEVer() {
  if (window) {
    var ua = window.navigator.userAgent;
    var idx = ua.indexOf('MSIE');
    if (idx > 0) {
      // "Mozilla/5.0 (compatible; MSIE 10.0; Windows NT 6.1; WOW64;
      // Trident/6.0; SLCC2; .NET CLR 2.0.50727)"
      return parseInt(ua.substring(idx + 5, ua.indexOf('.', idx)), 10);
    }
    if (ua.match(/Trident\/7\./)) {
      // "Mozilla/5.0 (Windows NT 6.1; WOW64; Trident/7.0; SLCC2;
      // .NET CLR 2.0.50727; rv:11.0) like Gecko"
      return 11;
    }
    return 0;
  }
  return 0;
};

/**
 * Add or Remove an item from an array if the item does/does not exist.
 * @param {any} item the item need to add/remove.
 * @param {array} arr the array to change.
 * @return {array} the changed array.
 */
var toggleItemInArr = function toggleItemInArr(item, arr) {
  var idx = arr.indexOf(item);
  if (idx !== -1) {
    arr.splice(idx, 1);
  } else {
    arr.push(item);
  }
  return arr;
};

/**
 * format a string using uxcore-formatter.
 * @param {string} value the string to be formatted
 * @param {string} type the format type
 * @param {string} delimiter the format delimiter
 * @return {string} the formatted string
 */

var formatValue = function formatValue(value, type, delimiter) {
  var newDelimiter = delimiter || ' ';
  if (value === null || value === undefined) {
    return value;
  }
  var newValue = value.toString();
  if (type === 'money') {
    return _uxcoreFormatter2["default"].money(newValue, newDelimiter);
  }
  if (type === 'card') {
    return _uxcoreFormatter2["default"].card(newValue, newDelimiter);
  }
  if (type === 'cnmobile') {
    return _uxcoreFormatter2["default"].cnmobile(newValue, newDelimiter);
  }
  return newValue;
};

var arrayConcat = function arrayConcat(oldArr, newArr, reverse) {
  var resArr = reverse ? newArr.concat(oldArr) : oldArr.concat(newArr);
  return resArr;
};

var getFindRowData = function getFindRowData() {
  var rowData = null;
  var parent = null;
  var index = -1;
  var findRowData = function findRowData(data, jsxId) {
    if (!data || !data.length || jsxId === undefined) {
      return { rowData: rowData, parent: parent, index: index };
    }
    for (var i = 0, len = data.length; i < len; i++) {
      var item = data[i];
      if (item.jsxid === jsxId) {
        rowData = item;
        parent = data;
        index = i;
        break;
      }
      if (item.data && item.data.length) {
        findRowData(item.data, jsxId);
      }
    }
    return { rowData: rowData, parent: parent, index: index };
  };
  return findRowData;
};

var mergeData = function mergeData(data, obj, reverse, targetId) {
  var newData = (0, _cloneDeep2["default"])(data);
  var expandedKey = void 0;
  if (targetId >= 0) {
    var findRowData = getFindRowData();

    var _findRowData = findRowData(newData.data, targetId),
        rowData = _findRowData.rowData;

    if (rowData) {
      if (rowData.data && rowData.data.length) {
        rowData.data = arrayConcat(rowData.data, obj, reverse);
      } else {
        rowData.data = obj;
      }
      expandedKey = rowData.jsxid;
    }
    return { data: newData, expandedKey: expandedKey };
  }

  // code compatible
  if (newData.datas) {
    newData.datas = arrayConcat(newData.datas, obj, reverse);
  } else if (newData.data) {
    newData.data = arrayConcat(newData.data, obj, reverse);
  }
  newData.totalCount += 1;
  return { data: newData, expandedKey: expandedKey };
};

/* eslint-disable no-param-reassign */
var saveRef = function saveRef(refName, context) {
  return function (c) {
    context[refName] = c;
  };
};
/* eslint-enable no-param-reassign */

// For changeTreeSelected in Table.js
// will change the first param data, be cautious.
var changeValueR = function changeValueR(data, key, value) {
  if (data.data && data.data instanceof Array) {
    for (var i = 0; i < data.data.length; i++) {
      var item = data.data[i];
      item[key] = value;
      changeValueR(item, key, value);
    }
  }
};

var hasFixColumn = function hasFixColumn(props) {
  var hasLeft = false;
  var hasRight = false;
  var columns = props.jsxcolumns.filter(function (item) {
    if (item.fixed) {
      hasLeft = true;
      return true;
    }
    if (item.rightFixed) {
      hasRight = true;
      return true;
    }
    return false;
  });
  if (columns.length > 0) {
    return {
      hasLeft: hasLeft,
      hasRight: hasRight
    };
  }
  return false;
};

var isRowHalfChecked = function isRowHalfChecked(rowData, checkboxColumnKey) {
  if (rowData.data) {
    var isHalfChecked = rowData.data.some(function (item) {
      if (item[checkboxColumnKey]) {
        return true;
      }
      return isRowHalfChecked(item, checkboxColumnKey);
    });
    return isHalfChecked;
  }
  return false;
};

// depth-first recursion of multi branches tree
var getAllSelectedRows = function getAllSelectedRows(rowData, checkboxColumnKey) {
  var selectedRows = [];
  var stack = [];
  // put first level data into stack
  stack.push(rowData);
  while (stack.length) {
    var item = stack.shift();
    if (item[checkboxColumnKey]) {
      selectedRows.push(item);
    }
    if (item.data) {
      stack = item.data.concat(stack);
    }
  }
  return selectedRows;
};

// TODO cache row tree set
// const getRowTreeSet = (rowData) => {
//   let stack = [];
//   // put first level data into stack
//   stack.push(rowData);
//   while (stack.length) {
//     const item = stack.shift();
//     if (item.data) {
//       stack = stack.concat(item.data);
//     }
//   }
// };

var getSelectedKeys = function getSelectedKeys(columns) {
  var realColumns = [];
  var selectedKeys = [];
  var isHalfChecked = false;
  columns.forEach(function (item) {
    var isGroup = {}.hasOwnProperty.call(item, 'columns') && _typeof(item.columns) === 'object';
    if (isGroup) {
      realColumns = realColumns.concat(item.columns);
    } else {
      realColumns.push(item);
    }
  });
  realColumns.forEach(function (item) {
    if (!item.hidden && item.dataKey && ['jsxchecked', 'jsxtreeIcon'].indexOf(item.dataKey) === -1 && item.type !== 'action') {
      selectedKeys.push(item.dataKey);
    } else if (item.hidden && item.dataKey) {
      isHalfChecked = true;
    }
  });
  return { selectedKeys: selectedKeys, isHalfChecked: isHalfChecked };
};

var getConsts = function getConsts() {
  return {
    commonGroup: '__common__'
  };
};

var getDefaultExpandedKeys = function getDefaultExpandedKeys(data, levels) {
  var level = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;

  var expandedKeys = [];
  if (Array.isArray(data)) {
    data.forEach(function (item) {
      if (level <= levels) {
        expandedKeys.push(item.jsxid);
        expandedKeys = expandedKeys.concat(getDefaultExpandedKeys(item.data, levels, level + 1));
      }
    });
  }
  return expandedKeys;
};

var measureScrollbar = function measureScrollbar() {
  if (typeof document === 'undefined' || typeof window === 'undefined') {
    return 0;
  }
  if (scrollbarWidth) {
    return scrollbarWidth;
  }
  var scrollDiv = document.createElement('div');
  Object.keys(scrollbarMeasure).forEach(function (scrollProp) {
    if (Object.hasOwnProperty.call(scrollbarMeasure, scrollProp)) {
      scrollDiv.style[scrollProp] = scrollbarMeasure[scrollProp];
    }
  });
  document.body.appendChild(scrollDiv);
  var width = scrollDiv.offsetWidth - scrollDiv.clientWidth;
  document.body.removeChild(scrollDiv);
  scrollbarWidth = width;
  return scrollbarWidth;
};

/* eslint-disable no-param-reassign */

var toggleHeightAnim = function toggleHeightAnim(node, show, done) {
  var height = void 0;
  (0, _cssAnimation2["default"])(node, '__css-animation__', {
    start: function start() {
      node.style.overflow = 'hidden';
      if (!show) {
        node.style.height = node.offsetHeight + 'px';
        node.style.opacity = 0;
      } else {
        height = node.offsetHeight;
        node.style.height = 0;
        node.style.opacity = 1;
      }
    },
    active: function active() {
      node.style.height = (show ? height : 0) + 'px';
    },
    end: function end() {
      node.style.height = '';
      node.style.overflow = '';
      done();
    }
  });
};

/**
 * recursively drop key from object
 * @param {*} obj object to drop key
 */
var dropFunc = function dropFunc(obj) {
  if (Array.isArray(obj)) {
    var newArr = [];
    obj.forEach(function (item) {
      if (typeof item !== 'function') {
        newArr.push(dropFunc(item));
      }
    });
    return newArr;
  }
  if (obj && (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) === 'object') {
    var newObj = {};
    Object.keys(obj).forEach(function (key) {
      var value = obj[key];
      // by taoqili _owner属性存在循环引用, 过滤掉；否则会造成本方法递归溢出
      if (typeof value !== 'function' && !/^_/.test(key)) {
        newObj[key] = dropFunc(value);
      }
    });
    return newObj;
  }
  return obj;
};

var getColumnsInfo = function getColumnsInfo(columns, includeActionColumn, excludeHiddenColumn) {
  var blackList = { 'jsxchecked': 1, 'jsxtreeIcon': 1, 'jsxwhite': 1 };
  var columnsKey = [];
  var actionColumn = null;
  var otherColumns = [];
  var readOnlyColumnKeys = [];
  var actionColumnPos = -1;
  var fixedColumns = [];
  return {
    columns: columns.filter(function (column, index) {
      if (column.dataKey in blackList || excludeHiddenColumn && column.hidden) {
        otherColumns.push(column);
        return false;
      }
      if (column.type === 'action') {
        actionColumn = column;
        if (!includeActionColumn) {
          actionColumnPos = index;
        }
        if (!column.fixed) {
          return includeActionColumn;
        }
      }
      if (column.disable) {
        readOnlyColumnKeys.push(column.dataKey);
      } else if (column.isDisable && column.isDisable()) {
        readOnlyColumnKeys.push(column.dataKey);
      }

      if (column.fixed || column.rightFixed) {
        fixedColumns.push(column);
      }
      columnsKey.push(column.dataKey);
      return true;
    }),
    columnsKey: columnsKey,
    actionColumn: actionColumn,
    actionColumnPos: actionColumnPos,
    otherColumns: otherColumns,
    fixedColumns: fixedColumns,
    readOnlyColumnKeys: readOnlyColumnKeys
  };
};

var checkColumnExist = function checkColumnExist(columns, column) {
  if (!columns || !columns.length || !column) {
    return false;
  }
  var flag = false;
  for (var i = 0, len = columns.length; i < len; i++) {
    if (columns[i].dataKey === column.dataKey) {
      flag = true;
      break;
    }
  }
  return flag;
};

/* eslint-enable no-param-reassign */

var utils = {
  getIEVer: getIEVer,
  toggleItemInArr: toggleItemInArr,
  formatValue: formatValue,
  getSelectedKeys: getSelectedKeys,
  changeValueR: changeValueR,
  isRowHalfChecked: isRowHalfChecked,
  getAllSelectedRows: getAllSelectedRows,
  getConsts: getConsts,
  saveRef: saveRef,
  mergeData: mergeData,
  hasFixColumn: hasFixColumn,
  getDefaultExpandedKeys: getDefaultExpandedKeys,
  measureScrollbar: measureScrollbar,
  toggleHeightAnim: toggleHeightAnim,
  dropFunc: dropFunc,
  getColumnsInfo: getColumnsInfo,
  checkColumnExist: checkColumnExist,
  getFindRowData: getFindRowData
};

exports["default"] = utils;
module.exports = exports['default'];