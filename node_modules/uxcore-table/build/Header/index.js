'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _objectAssign = require('object-assign');

var _objectAssign2 = _interopRequireDefault(_objectAssign);

var _classnames = require('classnames');

var _classnames2 = _interopRequireDefault(_classnames);

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _propTypes = require('prop-types');

var _propTypes2 = _interopRequireDefault(_propTypes);

var _addEventListener = require('rc-util/lib/Dom/addEventListener');

var _addEventListener2 = _interopRequireDefault(_addEventListener);

var _util = require('../util');

var _util2 = _interopRequireDefault(_util);

var _HeaderCell = require('./HeaderCell');

var _HeaderCell2 = _interopRequireDefault(_HeaderCell);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); } /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Created by xy on 15/4/13.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */


var leftFixedType = ['checkboxSelector', 'radioSelector', 'treeIcon'];

var Header = function (_React$Component) {
  _inherits(Header, _React$Component);

  function Header() {
    _classCallCheck(this, Header);

    return _possibleConstructorReturn(this, _React$Component.apply(this, arguments));
  }

  Header.prototype.componentDidMount = function componentDidMount() {
    var me = this;
    var fixedColumn = me.props.fixedColumn;

    if (fixedColumn === 'scroll') {
      me.rootEl = me.root;
      me.scrollHandler = me.onScroll.bind(me);
      me.scrollListener = (0, _addEventListener2["default"])(me.rootEl, 'scroll', me.scrollHandler);
    }
  };

  Header.prototype.componentWillUnmount = function componentWillUnmount() {
    if (this.scrollListener) {
      this.scrollListener.remove();
    }
  };

  Header.prototype.onScroll = function onScroll() {
    var me = this;
    var fixedColumn = me.props.fixedColumn;

    if (me.scrollEndTimer) {
      clearTimeout(me.scrollEndTimer);
    }
    me.scrollEndTimer = setTimeout(function () {
      me.props.onScroll(me.rootEl.scrollLeft, me.rootEl.scrollTop, fixedColumn);
    }, 500);
    me.props.onScroll(me.rootEl.scrollLeft, me.rootEl.scrollTop, fixedColumn);
  };

  Header.prototype.getDom = function getDom() {
    return this.root;
  };

  Header.prototype.getScroller = function getScroller() {
    return this.scroller;
  };

  Header.prototype.getFixedColumnsWidth = function getFixedColumnsWidth() {
    var _this2 = this;

    var width = 0;
    var cellKeys = Object.keys(this).filter(function (item) {
      return (/fixedCell\d/.test(item)
      );
    });
    cellKeys.forEach(function (key) {
      if (_this2[key]) {
        width += _this2[key].getWidth();
      }
    });
    return width;
  };

  Header.prototype.saveRef = function saveRef(refName) {
    var me = this;
    return function (c) {
      me[refName] = c;
    };
  };

  Header.prototype.handleColumnOrder = function handleColumnOrder(column) {
    var me = this;
    var _me$props = me.props,
        orderColumnCB = _me$props.orderColumnCB,
        activeColumn = _me$props.activeColumn,
        orderType = _me$props.orderType;

    var type = 'desc';
    var typeMap = {
      desc: 'asc',
      asc: 'none',
      none: 'desc'
    };
    if (activeColumn && column.dataKey === activeColumn.dataKey && orderType) {
      type = typeMap[orderType];
    }
    if (orderColumnCB) {
      orderColumnCB(type, column);
    }
  };

  Header.prototype.handleCheckBoxChange = function handleCheckBoxChange(e) {
    var v = e.target.checked;
    this.props.selectAll.apply(null, [v]);
  };

  Header.prototype.handleColumnFilter = function handleColumnFilter(filterKeys, column) {
    this.props.onColumnFilter(filterKeys, column);
  };

  Header.prototype.renderColumn = function renderColumn(item, index, hasGroup, last) {
    var _this3 = this;

    var me = this;
    var _me$props2 = me.props,
        renderModel = _me$props2.renderModel,
        checkboxColumnKey = _me$props2.checkboxColumnKey,
        prefixCls = _me$props2.prefixCls,
        orderType = _me$props2.orderType,
        activeColumn = _me$props2.activeColumn,
        checkStatus = _me$props2.checkStatus,
        filterColumns = _me$props2.filterColumns,
        tablePrefixCls = _me$props2.tablePrefixCls,
        columnResizeable = _me$props2.columnResizeable,
        handleColumnResize = _me$props2.handleColumnResize,
        isStickyHeader = _me$props2.isStickyHeader,
        fixedColumn = _me$props2.fixedColumn,
        size = _me$props2.size,
        tooltipPlacement = _me$props2.tooltipPlacement;

    var cellProps = {
      column: item,
      index: index,
      hasGroup: hasGroup,
      last: last,
      renderModel: renderModel,
      checkboxColumnKey: checkboxColumnKey,
      prefixCls: prefixCls,
      orderType: orderType,
      activeColumn: activeColumn,
      filterSelectedKeys: filterColumns[item.dataKey],
      checkStatus: checkStatus,
      tablePrefixCls: tablePrefixCls,
      isStickyHeader: isStickyHeader,
      tooltipPlacement: tooltipPlacement,
      ref: function ref(c) {
        if (Header.isFixedColumn(item)) {
          _this3['fixedCell' + index] = c;
        }
      },
      onCheckboxChange: function onCheckboxChange(e) {
        _this3.handleCheckBoxChange(e);
      },
      onColumnOrder: function onColumnOrder() {
        _this3.handleColumnOrder(item);
      },
      onFilter: function onFilter(filterKeys) {
        _this3.handleColumnFilter(filterKeys, item);
      },
      columnResizeable: columnResizeable,
      handleColumnResize: handleColumnResize,
      isFixedHeader: fixedColumn === 'fixed' || fixedColumn === 'rightFixed',
      size: size
    };
    return _react2["default"].createElement(_HeaderCell2["default"], _extends({}, cellProps, { key: index }));
  };

  Header.prototype.renderColumns = function renderColumns(_columns) {
    var me = this;
    var _props = this.props,
        prefixCls = _props.prefixCls,
        hasGroup = _props.hasGroup,
        size = _props.size;

    var columns = _columns.map(function (item, index) {
      var last = index === _columns.length - 1;
      if ({}.hasOwnProperty.call(item, 'columns') && _typeof(item.columns) === 'object') {
        // First determine whether the group should be rendered, if all columns
        // is hidden, the column group should not be rendered.
        var shouldRenderGroup = item.columns.some(function (column) {
          return !column.hidden;
        });
        if (shouldRenderGroup) {
          return _react2["default"].createElement(
            'div',
            {
              className: prefixCls + '-column-group',
              key: index
            },
            _react2["default"].createElement(
              'div',
              {
                className: (0, _classnames2["default"])(prefixCls + '-group-name', {
                  last: last
                }),
                style: {
                  lineHeight: size === 'small' ? '40px' : '50px'
                }
              },
              item.group
            ),
            item.columns.map(function (column, i) {
              var shouldHideBorderRight = i === item.columns.length - 1 && last && me.props.fixedColumn !== 'fixed';
              return me.renderColumn(column, i, false, shouldHideBorderRight);
            })
          );
        }
        return null;
      }
      return me.renderColumn(item, index, hasGroup, last);
    });
    return columns;
  };

  Header.prototype.render = function render() {
    var _this4 = this;

    var props = this.props;

    var me = this;
    var headerStyle = {};
    var scrollBarWidth = _util2["default"].measureScrollbar();
    var width = 0;
    var headerWrapClassName = void 0;
    var columns = void 0;

    if (props.fixedColumn === 'fixed') {
      columns = props.columns.filter(function (item) {
        if (!item.hidden && Header.isFixedColumn(item)) {
          width = parseInt(item.width, 10) + width;
          return true;
        }
        return false;
      });
      headerWrapClassName = props.prefixCls + '-fixed';
      if (props.leftFixedMaxWidth) {
        (0, _objectAssign2["default"])(headerStyle, {
          marginBottom: '-' + scrollBarWidth + 'px',
          overflowX: scrollBarWidth ? 'scroll' : 'hidden'
        });
      }
    } else if (props.fixedColumn === 'rightFixed') {
      columns = props.columns.filter(function (item) {
        if (item.rightFixed && !item.hidden) {
          width = parseInt(item.width, 10) + width;
          return true;
        }
        return false;
      });
      headerWrapClassName = props.prefixCls + '-right-fixed';
    } else if (props.fixedColumn === 'scroll') {
      var leftFixedColumns = [];
      var normalColumns = [];
      var rightFixedColumns = [];
      props.columns.forEach(function (item) {
        if (!item.hidden) {
          if (Header.isFixedColumn(item)) {
            leftFixedColumns.push(item);
          } else if (item.rightFixed) {
            rightFixedColumns.push(item);
          } else {
            normalColumns.push(item);
          }
        }
      });

      columns = leftFixedColumns.concat(normalColumns, rightFixedColumns);

      (0, _objectAssign2["default"])(headerStyle, {
        marginBottom: '-' + scrollBarWidth + 'px',
        overflowX: scrollBarWidth ? 'scroll' : 'hidden'
      });
      headerWrapClassName = props.prefixCls + '-scroll';
    } else {
      columns = props.columns;

      headerWrapClassName = props.prefixCls + '-no';
    }
    return _react2["default"].createElement(
      'div',
      { className: headerWrapClassName, style: headerStyle, ref: me.saveRef('root') },
      _react2["default"].createElement(
        'div',
        { className: props.prefixCls, ref: function ref(c) {
            _this4.scroller = c;
          } },
        me.renderColumns(columns)
      )
    );
  };

  return Header;
}(_react2["default"].Component);

Header.isFixedColumn = function (item) {
  return item.fixed || leftFixedType.indexOf(item.type) !== -1;
};

Header.propTypes = {
  handleColumnPickerChange: _propTypes2["default"].func,
  selectAll: _propTypes2["default"].func,
  prefixCls: _propTypes2["default"].string,
  onColumnFilter: _propTypes2["default"].func,
  filterColumns: _propTypes2["default"].object,
  isStickyHeader: _propTypes2["default"].bool
};

Header.defaultProps = {
  handleColumnPickerChange: function handleColumnPickerChange() {},
  selectAll: function selectAll() {},
  prefixCls: 'kuma-uxtable-header',
  onColumnFilter: function onColumnFilter() {},
  filterColumns: {},
  isStickyHeader: false
};

exports["default"] = Header;
module.exports = exports['default'];