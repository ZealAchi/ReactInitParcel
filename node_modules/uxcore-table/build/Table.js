'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _uxcoreCellField = require('uxcore-cell-field');

var _uxcoreCellField2 = _interopRequireDefault(_uxcoreCellField);

var _uxcorePagination = require('uxcore-pagination');

var _uxcorePagination2 = _interopRequireDefault(_uxcorePagination);

var _uxcoreConst = require('uxcore-const');

var _uxcoreConst2 = _interopRequireDefault(_uxcoreConst);

var _objectAssign = require('object-assign');

var _objectAssign2 = _interopRequireDefault(_objectAssign);

var _cloneDeep = require('lodash/cloneDeep');

var _cloneDeep2 = _interopRequireDefault(_cloneDeep);

var _upperFirst = require('lodash/upperFirst');

var _upperFirst2 = _interopRequireDefault(_upperFirst);

var _isEqual = require('lodash/isEqual');

var _isEqual2 = _interopRequireDefault(_isEqual);

var _classnames3 = require('classnames');

var _classnames4 = _interopRequireDefault(_classnames3);

var _nattyFetch = require('natty-fetch');

var _nattyFetch2 = _interopRequireDefault(_nattyFetch);

var _lie = require('lie');

var _lie2 = _interopRequireDefault(_lie);

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _uxcoreAnimate = require('uxcore-animate');

var _uxcoreAnimate2 = _interopRequireDefault(_uxcoreAnimate);

var _class = require('rc-util/lib/Dom/class');

var _css = require('rc-util/lib/Dom/css');

var _addEventListener = require('rc-util/lib/Dom/addEventListener');

var _addEventListener2 = _interopRequireDefault(_addEventListener);

var _reactLifecyclesCompat = require('react-lifecycles-compat');

var _uxcoreSticky = require('uxcore-sticky');

var _uxcoreSticky2 = _interopRequireDefault(_uxcoreSticky);

var _Mask = require('./Mask');

var _Mask2 = _interopRequireDefault(_Mask);

var _util = require('./util');

var _util2 = _interopRequireDefault(_util);

var _Header = require('./Header');

var _Header2 = _interopRequireDefault(_Header);

var _Footer = require('./Footer');

var _Footer2 = _interopRequireDefault(_Footer);

var _Tbody = require('./Tbody');

var _Tbody2 = _interopRequireDefault(_Tbody);

var _ActionBar = require('./ActionBar');

var _ActionBar2 = _interopRequireDefault(_ActionBar);

var _methods = require('./methods');

var _methods2 = _interopRequireDefault(_methods);

var _innerMethods = require('./innerMethods');

var _innerMethods2 = _interopRequireDefault(_innerMethods);

var _prop = require('./prop');

var _context = require('./context');

var _context2 = _interopRequireDefault(_context);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); } /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Table Component for uxcore
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @author zhouquan.yezq
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Copyright 2014-2015, UXCore Team, Alinw.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * All rights reserved.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

var createCellField = _uxcoreCellField2["default"].createCellField;

var getStyle = _css.get;

var Table = function (_React$Component) {
  _inherits(Table, _React$Component);

  function Table(props) {
    _classCallCheck(this, Table);

    var _this = _possibleConstructorReturn(this, _React$Component.call(this, props));

    _initialiseProps.call(_this);

    _this.bindInnerMethods();
    _this.uid = 0;
    _this.fields = {};
    _this.copyData = (0, _cloneDeep2["default"])(props.jsxdata);
    _this.data = _this.addValuesInData((0, _cloneDeep2["default"])(props.jsxdata));
    _this.state = _extends({
      data: _this.data }, Table.processColumn(props), { // column 内部交互
      showMask: props.showMask, // fetchData 时的内部状态改变
      pageSize: props.pageSize, // pagination 相关
      currentPage: props.currentPage, // pagination 相关
      activeColumn: null,
      searchTxt: '',
      isStickyHeader: false,
      expandedKeys: [],
      filterColumns: {},
      treeLoadingIds: [],
      hasFixed: _util2["default"].hasFixColumn(props),
      // mirror for gDSFP
      lastPageSize: props.pageSize,
      lastCurrentPage: props.currentPage,
      lastJsxcolumns: props.jsxcolumns,
      lastShowMask: props.showMask,
      customView: null,
      removeCustomPager: false
    });
    _this.hasGroup = _this.checkHasGroup(props.jsxcolumns);
    _this.handleBodyScroll = _this.handleBodyScroll.bind(_this);
    _this.handleHeaderScroll = _this.handleHeaderScroll.bind(_this);
    _this.changeSelected = _this.changeSelected.bind(_this);
    _this.handleDataChange = _this.handleDataChange.bind(_this);
    _this.attachCellField = _this.attachCellField.bind(_this);
    _this.detachCellField = _this.detachCellField.bind(_this);
    _this.selectAll = _this.selectAll.bind(_this);
    _this.handleOrderColumnCB = _this.handleOrderColumnCB.bind(_this);
    _this.handleColumnPickerChange = _this.handleColumnPickerChange.bind(_this);
    _this.handleActionBarSearch = _this.handleActionBarSearch.bind(_this);
    _this.handleFilter = _this.handleFilter.bind(_this);
    props.needCheckRightFixed && setInterval(function () {
      _this.rightFixedTable && _this.checkRightFixed(true);
    }, 300);
    return _this;
  }

  Table.prototype.checkHasGroup = function checkHasGroup(columns) {
    var ret = false;
    for (var i = 0; i < columns.length; i++) {
      if (columns[i].group) {
        ret = true;
        break;
      }
    }
    return ret;
  };

  Table.prototype.componentDidMount = function componentDidMount() {
    var me = this;
    if (!!me.state.data && !!me.state.data.datas) {
      console.warn('Table: "content.data" rather than "content.datas" is recommended, ' + 'the support for "content.datas" will be end from ver. 1.5.0');
    }
    if (me.props.subComp) {
      console.warn('Table: subComp is deprecated, use renderSubComp instead.');
    }
    if (me.props.renderSubComp && this.state.hasFixed) {
      console.warn('Table: subComp cannot be rendered if fixed column exists, remove fixed column or props.renderSubComp');
    }
    if (this.props.fetchDataOnMount) {
      this.fetchData();
    }
    this.bindMethods();
    this.resizeListener = this.listenWindowResize();
    if (this.root) {
      this.rootWidth = this.root.clientWidth;
    }
  };

  Table.prototype.componentDidUpdate = function componentDidUpdate(prevProps) {
    var _this2 = this;

    if (this.props.jsxdata && !(0, _isEqual2["default"])(this.props.jsxdata, this.copyData)) {
      this.fetchData('dataChange', this.props);
      // TODO: need reduce times
      this.forceToCheckRight = true;
    }
    if (prevProps.fetchUrl !== this.props.fetchUrl || !(0, _isEqual2["default"])(prevProps.fetchParams, this.props.fetchParams)) {
      this.fetchData('propsChange', this.props, function () {
        _this2.checkRightFixed(true);
      });
    }

    if (this.state.hasPercentWidth && this.root && this.root.clientWidth !== this.state.tableWidth) {
      /* eslint-disable react/no-did-update-set-state */
      this.setState(function (state) {
        var newState = _extends({
          tableWidth: _this2.root.clientWidth
        }, Table.processColumn(_this2.props, state, { tableWidth: _this2.root.clientWidth }));
        if (state.forceToCheckRight) {
          _this2.checkRightFixed(true);
          newState.forceToCheckRight = false;
        }
        return newState;
      });
      /* eslint-enable react/no-did-update-set-state */
    }
    // TODO: performance need to be cared
    this.checkBodyVScroll();
    this.checkBodyHScroll();
    this.checkRightFixed(this.forceToCheckRight);
    this.forceToCheckRight = false;
    this.checkFixedMaxWidth();
  };

  Table.prototype.componentWillUnmount = function componentWillUnmount() {
    if (this.resizeListener) {
      this.resizeListener.remove();
    }
  };

  Table.prototype.useCustomView = function useCustomView(view, removeCustomPager) {
    this.setState({
      customView: view,
      removeCustomPager: removeCustomPager
    });
  };

  /**
   * register CellField to Table for the global validation
   * @param field {element} the cell field to be registered
   */

  Table.prototype.attachCellField = function attachCellField(validate, name) {
    var me = this;
    if (!name) {
      console.error('Table: dataKey can not be undefined, check the column config');
    } else {
      me.fields[name] = validate;
    }
  };

  Table.prototype.bindInnerMethods = function bindInnerMethods() {
    var me = this;
    Object.keys(_innerMethods2["default"]).forEach(function (key) {
      me[key] = _innerMethods2["default"][key].bind(me);
    });
  };

  Table.prototype.bindMethods = function bindMethods() {
    var me = this;
    Object.keys(_methods2["default"]).forEach(function (key) {
      me[key] = _methods2["default"][key].bind(me);
    });
  };

  /**
   * change SelectedRows data via checkbox, this function will pass to the Cell
   * @param checked {boolean} the checkbox status
   * @param rowIndex {number} the row Index
   * @param fromMount {boolean} onSelect is called from cell Mount is not expected.
   */

  Table.prototype.changeSelected = function changeSelected(checked, rowIndex, fromMount) {
    var me = this;
    var content = (0, _cloneDeep2["default"])(this.state.data);
    var _data = content.datas || content.data;

    if (me.state.checkboxColumn.type === 'radioSelector') {
      for (var i = 0; i < _data.length; i++) {
        var item = _data[i];
        if (item.jsxid === rowIndex) {
          item[me.state.checkboxColumnKey] = checked;
        } else if (item[me.state.checkboxColumnKey]) {
          item[me.state.checkboxColumnKey] = false;
        }
      }
    } else {
      for (var _i = 0; _i < _data.length; _i++) {
        var _item = _data[_i];
        if (_item.jsxid === rowIndex) {
          _item[me.state.checkboxColumnKey] = checked;
          break;
        }
      }
    }

    me.setState({
      data: content
    }, function () {
      if (!fromMount) {
        var data = me.state.data.datas || me.state.data.data;
        var selectedRows = data.filter(function (item) {
          return item[me.state.checkboxColumnKey] === true;
        });
        if (me.props.rowSelection && me.props.rowSelection.onSelect) {
          me.props.rowSelection.onSelect(checked, data[rowIndex], selectedRows);
        }
      }
    });
  };

  /**
   * change the checkboxColumnKey of data, passed to the Row
   * @param checked {boolean} tree checkbox status
   * @param dataIndex {string} like `1-2-3` means the position of the Row in data
   */


  Table.prototype.changeTreeSelected = function changeTreeSelected(checked, dataIndex) {
    var me = this;
    var currentLevel = dataIndex.toString().split('-');
    var levelDepth = currentLevel.length;
    var data = (0, _cloneDeep2["default"])(me.state.data);
    var current = data.data;
    // record each tree node for reverse recursion.
    var treeMap = [];
    for (var i = 0; i < levelDepth - 1; i++) {
      treeMap[i] = current;
      current = current[currentLevel[i]].data;
    }
    // check/uncheck current row and all its children
    current = current[currentLevel[levelDepth - 1]];
    current[me.state.checkboxColumnKey] = checked;
    _util2["default"].changeValueR(current, me.state.checkboxColumnKey, checked);

    // reverse recursion, check/uncheck parents by its children.
    for (var _i2 = treeMap.length - 1; _i2 >= 0; _i2--) {
      treeMap[_i2][currentLevel[_i2]][me.state.checkboxColumnKey] = treeMap[_i2][currentLevel[_i2]].data.every(function (item) {
        return item[me.state.checkboxColumnKey] === true;
      });
    }

    me.setState({
      data: data
    }, function () {
      var selectedRows = _util2["default"].getAllSelectedRows((0, _cloneDeep2["default"])(data), me.state.checkboxColumnKey);
      if (me.props.rowSelection && me.props.rowSelection.onSelect) {
        me.props.rowSelection.onSelect(checked, current, selectedRows);
      }
    });
  };

  /**
   * check if right fixed table is needed.
   * if table is wide enough, hide the right fixed.
   * @param force force to check
   */


  Table.prototype.checkRightFixed = function checkRightFixed(force) {
    if (this.rightFixedTable) {
      var headerScroll = this.headerScroll;

      var headerScrollDom = headerScroll.getDom();
      if (force !== true && this.cachedHeaderScrollWidth === headerScrollDom.clientWidth) {
        return;
      }
      var headerScrollInner = headerScroll.getScroller();
      this.cachedHeaderScrollWidth = headerScrollDom.clientWidth;
      if (headerScrollInner.clientWidth === headerScrollDom.clientWidth && getStyle(this.rightFixedTable, 'display') === 'block') {
        this.rightFixedTable.style.display = 'none';
      } else if (headerScrollInner.clientWidth > headerScrollDom.clientWidth && getStyle(this.rightFixedTable, 'display') === 'none') {
        this.rightFixedTable.style.display = 'block';
      }
    }
  };

  /**
   * hide vertical scrollbar if table is not vertically scrollable
   */


  Table.prototype.checkBodyVScroll = function checkBodyVScroll() {
    if (this.bodyScroll) {
      var prefixCls = this.props.prefixCls;

      var node = this.bodyScroll.getDom();
      // body does not exist if no data
      if (node.children[0]) {
        var wrapperHeight = node.clientHeight;
        var bodyHeight = node.children[0].clientHeight;
        var headerDom = this.headerScroll ? this.headerScroll.getDom() : null;
        var footerDom = this.footerScroll ? this.footerScroll.getDom() : null;
        var noVScroll = bodyHeight <= wrapperHeight;
        if (this.noVScroll === undefined || this.noVScroll !== noVScroll) {
          if (noVScroll) {
            (0, _class.addClass)(node, prefixCls + '-no-v-scroll');
            if (headerDom) {
              (0, _class.addClass)(headerDom, prefixCls + '-no-v-scroll');
            }
            if (footerDom) {
              (0, _class.addClass)(footerDom, prefixCls + '-no-v-scroll');
            }
          } else {
            (0, _class.removeClass)(node, prefixCls + '-no-v-scroll');
            if (headerDom) {
              (0, _class.removeClass)(headerDom, prefixCls + '-no-v-scroll');
            }
            if (footerDom) {
              (0, _class.removeClass)(footerDom, prefixCls + '-no-v-scroll');
            }
          }
          this.noVScroll = noVScroll;
        }
      }
    }
  };

  /**
   * add fixed body box-shadow when body is scrolling horizontally
   * @param {number} scrollLeft body's current scrollLeft
   */


  Table.prototype.checkBodyHScroll = function checkBodyHScroll(scrollLeft) {
    if (!this.state.hasFixed) {
      return false;
    }
    if (!this.bodyScroll) {
      return false;
    }
    var node = this.bodyScroll.getDom();
    var wrapperScrollLeft = scrollLeft || node.scrollLeft;
    if (this.state.hasFixed.hasLeft && this.fixedTable) {
      if (wrapperScrollLeft > 0) {
        (0, _class.addClass)(this.fixedTable, 'has-scroll');
      } else {
        (0, _class.removeClass)(this.fixedTable, 'has-scroll');
      }
    }
    if (this.state.hasFixed.hasRight) {
      var wrapperWidth = node.clientWidth;
      if (node.children[0]) {
        var bodyWidth = node.children[0].clientWidth;
        if (this.rightFixedTable) {
          if (wrapperScrollLeft + wrapperWidth + 3 < bodyWidth) {
            (0, _class.addClass)(this.rightFixedTable, 'end-of-scroll');
          } else {
            (0, _class.removeClass)(this.rightFixedTable, 'end-of-scroll');
          }
        }
      }
    }
    return false;
  };

  /**
   * check if main table need to be right positioned if leftFixedMaxWidth is set
   */


  Table.prototype.checkFixedMaxWidth = function checkFixedMaxWidth() {
    var leftFixedMaxWidth = this.props.leftFixedMaxWidth;

    if (!leftFixedMaxWidth || !this.headerFixed || !this.mainTable) return;
    var fixedColumnsWidth = this.headerFixed.getFixedColumnsWidth();
    if (fixedColumnsWidth && fixedColumnsWidth !== this.fixedColumnsWidth) {
      this.fixedColumnsWidth = fixedColumnsWidth;
      var offset = leftFixedMaxWidth - fixedColumnsWidth;
      if (offset < 0) {
        this.mainTable.style.position = 'relative';
        this.mainTable.style.left = offset + 'px';
        this.mainTable.style.width = 'calc(100% + ' + -offset + 'px)';
      } else {
        this.mainTable.style.left = '0px';
        this.mainTable.style.width = 'calc(100%)';
      }
    }
  };

  /**
   * cancel the CellField when it is unmounted.
   * @param {element} field  the cell field to be canceled.
   */

  Table.prototype.detachCellField = function detachCellField(name) {
    delete this.fields[name];
  };

  /**
   * fetch Data via Ajax
   * @param {string} from tell fetchData where it is invoked, the param will be
   * passed to props.beforeFetch in order to help the user.
   */

  Table.prototype.fetchData = function fetchData(from, nextProps, cb) {
    var me = this;
    var props = nextProps || this.props;
    // reset uid cause table data has changed
    me.uid = 0;

    // fetchUrl has the top priority.
    if (props.fetchUrl) {
      me.fetchRemoteData(from, props, cb);
    } else if (props.passedData) {
      me.fetchPassedData(props, cb);
    } else if (props.jsxdata) {
      me.fetchLocalData(from, props, cb);
    } else {
      // default will create one row
      var data = {
        data: [{
          jsxid: me.uid,
          __mode__: _uxcoreConst2["default"].MODE.EDIT
        }],
        currentPage: 1,
        totalCount: 0
      };
      me.uid += 1;
      me.data = data;
      me.setState({
        data: data
      });
    }
  };

  Table.prototype.fetchRemoteData = function fetchRemoteData(from, props) {
    var cb = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : function () {};

    var me = this;
    if (me.request) {
      me.request.abort();
    }
    if (!me.state.showMask) {
      me.setState({
        showMask: true
      });
    }

    var isJsonp = props.isJsonp === undefined ? /\.jsonp/.test(props.fetchUrl) : props.isJsonp;
    me.request = _nattyFetch2["default"].create({
      header: props.fetchHeader,
      method: props.fetchMethod,
      url: props.fetchUrl,
      willFetch: function willFetch(vars, config) {
        /* eslint-disable no-param-reassign */
        /* natty-fetch api design force to make param reassign */
        vars.data = props.beforeFetch((0, _cloneDeep2["default"])(vars.data), from, config);
        /* eslint-enable no-param-reassign */
      },
      data: me.getQueryObj(from, props),
      fit: props.fitResponse,
      withCredentials: props.fetchWithCredentials,
      jsonp: isJsonp,
      Promise: _lie2["default"]
    });

    me.request().then(function (content) {
      // Data has changed, so uid which is used to mark the data should be reset.
      me.uid = 0;
      var processedData = me.addValuesInData(props.processData((0, _cloneDeep2["default"])(content))) || {};
      var updateObj = {
        data: processedData,
        showMask: false
      };
      var resetExpandedKeys = props.shouldResetExpandedKeys(from) !== false;
      if (resetExpandedKeys) {
        updateObj.expandedKeys = _util2["default"].getDefaultExpandedKeys(processedData.data, props.levels);
      }
      if (from === 'search') {
        updateObj.currentPage = 1;
      }
      if (processedData.currentPage !== undefined) {
        updateObj.currentPage = processedData.currentPage;
      }
      me.data = (0, _cloneDeep2["default"])(processedData);
      me.setState(updateObj, function () {
        cb();
      });
    })["catch"](function (err) {
      props.onFetchError(err);
      me.setState({
        data: {
          data: []
        },
        showMask: false
      });
    });
  };

  Table.prototype.fetchPassedData = function fetchPassedData(props) {
    var cb = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function () {};

    console.warn('props subComp is deprecated, use renderSubComp instead.');
    var me = this;
    if (!props.queryKeys) {
      var data = me.addValuesInData(props.processData((0, _cloneDeep2["default"])(props.passedData)));
      me.setState({
        data: data
      });
      me.data = (0, _cloneDeep2["default"])(data);
    } else {
      var _data2 = {};
      props.queryKeys.forEach(function (key) {
        if (props.passedData[key] !== undefined) {
          _data2[key] = props.passedData[key];
        }
      });
      var processedData = me.addValuesInData(props.processData((0, _cloneDeep2["default"])(_data2)));
      me.data = (0, _cloneDeep2["default"])(processedData);
      me.setState({
        data: processedData
      }, function () {
        cb();
      });
    }
  };

  Table.prototype.fetchLocalData = function fetchLocalData(from, props) {
    var cb = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : function () {};

    var me = this;
    // Data has changed, so uid which is used to mark the data should be reset.
    me.uid = 0;
    if (['pagination', 'order', 'search', 'filter'].indexOf(from) !== -1) {
      if (from === 'pagination' && props.onPagerChange) {
        props.onPagerChange(this.state.currentPage, this.state.pageSize);
      }

      if (from === 'order' && props.onOrder) {
        props.onOrder(this.state.activeColumn, this.state.orderType);
      }

      if (from === 'search' && props.onSearch) {
        props.onSearch(this.state.searchTxt);
      }

      if (from === 'filter' && props.onFilter) {
        props.onFilter(this.state.filterColumns);
      }
    } else {
      this.copyData = (0, _cloneDeep2["default"])(props.jsxdata);
      var data = this.addValuesInData((0, _cloneDeep2["default"])(props.jsxdata));
      var currentPage = data && data.currentPage || this.state.currentPage;
      this.data = (0, _cloneDeep2["default"])(data);
      var updateObj = {
        data: data,
        currentPage: currentPage
      };
      var resetExpandedKeys = props.shouldResetExpandedKeys(from) !== false;
      if (resetExpandedKeys) {
        updateObj.expandedKeys = _util2["default"].getDefaultExpandedKeys(data.data, props.levels);
      }
      this.setState(updateObj, function () {
        cb();
      });
    }
  };

  /**
   * get Query Object by combining data from searchBar, column order, pagination
   * and fetchParams.
   * @param {string} from used in props.beforeFetch
   */

  Table.prototype.getQueryObj = function getQueryObj(from, props) {
    var me = this;
    var queryObj = {};
    if (props.passedData) {
      var queryKeys = props.queryKeys;

      if (!queryKeys) {
        queryObj = props.passedData;
      } else {
        queryKeys.forEach(function (key) {
          if (props.passedData[key] !== undefined) {
            queryObj[key] = props.passedData[key];
          }
        });
      }
    }

    // pagination
    queryObj = (0, _objectAssign2["default"])({}, queryObj, {
      pageSize: me.state.pageSize,
      currentPage: me.state.currentPage
    });

    // column order
    var _me$state = me.state,
        activeColumn = _me$state.activeColumn,
        orderType = _me$state.orderType;

    if (activeColumn) {
      queryObj = (0, _objectAssign2["default"])({}, queryObj, {
        orderColumn: activeColumn.dataKey
      });
      if (orderType && orderType !== 'none') {
        queryObj.orderType = orderType;
      }
    }

    // search query
    var searchTxt = me.state.searchTxt;

    if (searchTxt) {
      queryObj = (0, _objectAssign2["default"])({}, queryObj, {
        searchTxt: searchTxt
      });
    }

    // filter
    var filterColumns = this.state.filterColumns;

    if (filterColumns) {
      queryObj = _extends({}, queryObj, filterColumns);
    }

    if (['search', 'filter'].indexOf(from) !== -1) {
      queryObj = _extends({}, queryObj, { currentPage: 1 });
    }

    // fetchParams has the top priority
    if (props.fetchParams) {
      queryObj = (0, _objectAssign2["default"])({}, queryObj, props.fetchParams);
    }

    // return props.beforeFetch(deepcopy(queryObj), from);
    return queryObj;
  };

  Table.prototype.getCheckStatus = function getCheckStatus(data) {
    var me = this;
    var rowSelection = me.props.rowSelection;

    var column = me.state.checkboxColumn;
    if (!column || data.length === 0) {
      return false;
    }
    var checkboxColumnKey = me.state.checkboxColumnKey;

    var isAllDisabled = true;
    var isHalfChecked = false;
    var checkedColumn = 0;
    var enabledColumn = 0;
    for (var i = 0; i < data.length; i++) {
      var item = data[i];
      if (!column.disable && !(column.isDisable && column.isDisable(item)) && !((typeof rowSelection === 'undefined' ? 'undefined' : _typeof(rowSelection)) === 'object' && rowSelection.isDisabled && rowSelection.isDisabled(item))) {
        isAllDisabled = false;
        enabledColumn += 1;
        if (item[checkboxColumnKey]) {
          isHalfChecked = true;
          checkedColumn += 1;
        }
      }
    }
    var isAllChecked = enabledColumn ? checkedColumn === enabledColumn : false;
    return { isAllChecked: isAllChecked, isAllDisabled: isAllDisabled, isHalfChecked: isAllChecked ? false : isHalfChecked };
  };

  Table.prototype.getDom = function getDom() {
    return this.root;
  };

  Table.prototype.getMainBody = function getMainBody() {
    return this.bodyScroll;
  };

  Table.prototype.getPager = function getPager() {
    return this.pager;
  };

  Table.prototype.handleRowHover = function handleRowHover(index, isEnter) {
    var _this3 = this;

    if (!isEnter) {
      this.rowHoverTimer = setTimeout(function () {
        _this3.setState({
          currentHoverRow: -1
        });
      }, 100);
    } else {
      if (this.rowHoverTimer) {
        clearTimeout(this.rowHoverTimer);
        this.rowHoverTimer = null;
      }
      this.setState({
        currentHoverRow: index
      });
    }
  };

  Table.prototype.handleShowSizeChange = function handleShowSizeChange(current, pageSize) {
    var me = this;
    me.setState({
      currentPage: current,
      pageSize: pageSize
    }, function () {
      me.fetchData('pagination');
    });
  };

  Table.prototype.handleColumnPickerChange = function handleColumnPickerChange(checkedKeys, groupName) {
    var _this4 = this;

    var columns = (0, _cloneDeep2["default"])(this.state.columns);
    var notRenderColumns = ['jsxchecked', 'jsxtreeIcon', 'jsxwhite'];
    notRenderColumns.push(this.state.checkboxColumnKey);
    var commonGroupName = _util2["default"].getConsts().commonGroup;
    for (var i = 0; i < columns.length; i++) {
      var item = columns[i];
      var isGroup = {}.hasOwnProperty.call(item, 'columns') && _typeof(item.columns) === 'object';
      // current column is a group and groupName is right
      if (isGroup && item.group === groupName) {
        for (var j = 0; j < item.columns.length; j++) {
          var ele = item.columns[j];
          if (checkedKeys.indexOf(ele.dataKey) !== -1) {
            ele.hidden = false;
          } else {
            ele.hidden = true;
          }
        }
        break;
      } else if (groupName === commonGroupName && item.group === undefined) {
        // current column is common group
        if (checkedKeys.indexOf(item.dataKey) !== -1 || notRenderColumns.indexOf(item.dataKey) !== -1) {
          item.hidden = false;
        } else if (item.type !== 'action') {
          item.hidden = true;
        }
      }
    }

    var _util$getSelectedKeys = _util2["default"].getSelectedKeys(columns),
        selectedKeys = _util$getSelectedKeys.selectedKeys;

    if (selectedKeys.length === 0) {
      return;
    }

    this.setState({
      columns: columns
    }, function () {
      if (typeof _this4.props.onColumnPick === 'function') {
        _this4.props.onColumnPick((0, _cloneDeep2["default"])(columns));
      }
      _this4.checkRightFixed(true);
    });
  };

  Table.prototype.handleBodyScroll = function handleBodyScroll(scrollLeft, scrollTop, column) {
    this.bodyIsScorlling = true;
    if (this.headerIsScrolling) {
      this.headerIsScrolling = false;
      return;
    }
    if (this.footerIsScorlling) {
      this.footerIsScorlling = false;
      return;
    }
    var me = this;
    if (scrollLeft !== undefined && ['scroll', 'fixed'].indexOf(column) !== -1) {
      var headerNode = me['header' + (0, _upperFirst2["default"])(column)];
      var footerNode = me['footer' + (0, _upperFirst2["default"])(column)];
      if (headerNode) {
        headerNode.getDom().scrollLeft = scrollLeft;
      }
      if (footerNode) {
        footerNode.getDom().scrollLeft = scrollLeft;
      }
    }
    if (scrollTop !== undefined && this.state.hasFixed) {
      var columnType = ['fixed', 'rightFixed', 'scroll'];
      var columnToScroll = columnType.filter(function (item) {
        return item !== column;
      });
      columnToScroll.forEach(function (item) {
        var instance = me['body' + (0, _upperFirst2["default"])(item)];
        if (instance) {
          instance.getDom().scrollTop = scrollTop;
        }
      });
    }
    me.checkBodyHScroll(scrollLeft);
  };

  Table.prototype.handleHeaderScroll = function handleHeaderScroll(scrollLeft) {
    this.headerIsScrolling = true;
    if (this.bodyIsScorlling) {
      this.bodyIsScorlling = false;
      return;
    }
    if (this.footerIsScorlling) {
      this.footerIsScorlling = false;
      return;
    }
    if (scrollLeft !== undefined) {
      var me = this;
      var bodyNode = me.bodyScroll;
      bodyNode.getDom().scrollLeft = scrollLeft;
      var footerDom = me.footerScroll ? me.footerScroll.getDom() : null;
      if (footerDom) {
        footerDom.scrollLeft = scrollLeft;
      }
    }
  };

  Table.prototype.handleFooterScroll = function handleFooterScroll(scrollLeft) {
    this.footerIsScrolling = true;
    if (this.bodyIsScorlling) {
      this.bodyIsScorlling = false;
      return;
    }
    if (this.headerIsScrolling) {
      this.headerIsScrolling = false;
      return;
    }

    if (scrollLeft !== undefined) {
      var me = this;
      var bodyNode = me.bodyScroll;
      if (bodyNode) {
        bodyNode.getDom().scrollLeft = scrollLeft;
      }
      var headerDom = me.headerScrol ? me.headerScrol.getDom() : null;
      if (headerDom) {
        headerDom.scrollLeft = scrollLeft;
      }
    }
  };

  Table.prototype.handleOrderColumnCB = function handleOrderColumnCB(type, column) {
    var me = this;
    me.setState({
      activeColumn: column,
      orderType: type
    }, function () {
      me.fetchData('order');
    });
  };

  Table.prototype.handleFilter = function handleFilter(filterKeys, column) {
    var _this5 = this;

    var filterColumns = _extends({}, this.state.filterColumns);
    filterColumns[column.dataKey] = filterKeys;
    this.setState({
      filterColumns: filterColumns
    }, function () {
      _this5.fetchData('filter');
    });
  };

  Table.prototype.handleActionBarSearch = function handleActionBarSearch(value) {
    var me = this;
    this.setState({
      searchTxt: value
    }, function () {
      me.fetchData('search');
    });
  };

  /**
   * For inline edit
   * receive changes from cell field and change state.data
   * inform users of the change with dataKey & pass
   */

  Table.prototype.handleDataChange = function handleDataChange(obj) {
    var me = this;
    var jsxid = obj.jsxid,
        column = obj.column,
        value = obj.value,
        text = obj.text,
        pass = obj.pass;
    var dataKey = column.dataKey;

    var editKey = column.editKey || dataKey;
    var data = (0, _cloneDeep2["default"])(me.state.data);
    var changedData = {};
    for (var i = 0; i < data.data.length; i++) {
      if (data.data[i].jsxid === jsxid) {
        data.data[i][dataKey] = text;
        data.data[i][editKey] = value;
        changedData = data.data[i];
      }
    }

    me.setState({
      data: data
    }, function () {
      me.props.onChange({
        data: me.state.data,
        editKey: editKey,
        dataKey: dataKey,
        changedData: changedData,
        pass: pass
      });
    });
  };

  Table.prototype.listenWindowResize = function listenWindowResize() {
    var _this6 = this;

    return (0, _addEventListener2["default"])(window, 'resize', function () {
      _this6.checkRightFixed();
      _this6.resizeColumns();
      clearTimeout(_this6.adjustFixedTimer);
      _this6.adjustFixedTimer = setTimeout(function () {
        if (_this6.bodyFixed) {
          _this6.bodyFixed.adjustMultilineFixedRowHeight();
        }
        if (_this6.bodyRightFixed) {
          _this6.bodyRightFixed.adjustMultilineFixedRowHeight();
        }
      }, 200);
    });
  };

  Table.prototype.onPageChange = function onPageChange(current) {
    var me = this;
    me.setState({
      currentPage: current
    }, function () {
      me.fetchData('pagination');
    });
  };

  Table.prototype.resizeColumns = function resizeColumns() {
    var _this7 = this;

    if (this.state.hasPercentWidth && this.root && this.root.clientWidth !== this.rootWidth) {
      this.rootWidth = this.root.clientWidth;
      this.setState(function (state) {
        return _extends({}, Table.processColumn(_this7.props, state));
      });
    }
  };

  Table.prototype.selectAll = function selectAll(checked) {
    var me = this;
    var content = (0, _cloneDeep2["default"])(me.state.data);
    var data = content.datas || content.data;
    var rowSelection = me.props.rowSelection;


    var selectedRows = [];
    var changedRows = [];
    for (var i = 0; i < data.length; i++) {
      var column = me.state.checkboxColumn;
      var key = me.state.checkboxColumnKey;
      var item = data[i];
      if ((!('isDisable' in column) || !column.isDisable(item)) && !column.disable && !((typeof rowSelection === 'undefined' ? 'undefined' : _typeof(rowSelection)) === 'object' && rowSelection.isDisabled && rowSelection.isDisabled(item))) {
        if (!item[key] !== !checked) {
          changedRows.push(item);
        }
        item[key] = checked;
        selectedRows.push(item);
      }
    }

    if (!!rowSelection && !!rowSelection.onSelectAll) {
      rowSelection.onSelectAll.apply(null, [checked, checked ? selectedRows : [], changedRows]);
    }
    me.setState({
      data: content
    });
  };

  Table.prototype.hasFooter = function hasFooter() {
    return this.props.showFooter && typeof this.props.footer === 'function';
  };

  Table.prototype.renderTbody = function renderTbody(renderBodyProps, bodyHeight, fixedColumn) {
    var prefixCls = this.props.prefixCls;

    var isFixedTable = ['fixed', 'rightFixed'].indexOf(fixedColumn) !== -1;
    return _react2["default"].createElement(
      'div',
      {
        className: (0, _classnames4["default"])(prefixCls + '-body-wrapper', _defineProperty({}, prefixCls + '-fixed-body-wrapper', isFixedTable))
      },
      _react2["default"].createElement(_Tbody2["default"], _extends({}, renderBodyProps, {
        fixedColumn: fixedColumn,
        onScroll: this.handleBodyScroll,
        ref: _util2["default"].saveRef('body' + (0, _upperFirst2["default"])(fixedColumn), this)
      })),
      !isFixedTable ? _react2["default"].createElement(
        _uxcoreAnimate2["default"],
        { showProp: 'visible', transitionName: 'tableMaskFade' },
        _react2["default"].createElement(_Mask2["default"], { visible: this.state.showMask, text: this.props.loadingText })
      ) : null
    );
  };

  Table.prototype.renderHeader = function renderHeader(renderHeaderProps, fixedColumn) {
    var _props = this.props,
        prefixCls = _props.prefixCls,
        showHeader = _props.showHeader,
        fixHeaderToTop = _props.fixHeaderToTop,
        fixHeaderOffset = _props.fixHeaderOffset;

    if (!showHeader) {
      return null;
    }
    return _react2["default"].createElement(
      'div',
      { className: prefixCls + '-header-wrapper' },
      fixHeaderToTop ? _react2["default"].createElement(
        _uxcoreSticky2["default"],
        { offsetTop: fixHeaderOffset, onChange: this.handleHeaderFixedChanged },
        _react2["default"].createElement(_Header2["default"], _extends({}, renderHeaderProps, {
          fixedColumn: fixedColumn,
          ref: _util2["default"].saveRef('header' + (0, _upperFirst2["default"])(fixedColumn), this),
          onScroll: this.handleHeaderScroll,
          isStickyHeader: this.state.isStickyHeader
        }))
      ) : _react2["default"].createElement(_Header2["default"], _extends({}, renderHeaderProps, {
        fixedColumn: fixedColumn,
        ref: _util2["default"].saveRef('header' + (0, _upperFirst2["default"])(fixedColumn), this),
        onScroll: this.handleHeaderScroll
      }))
    );
  };

  Table.prototype.renderFooter = function renderFooter() {
    var _this8 = this;

    var renderFooterProps = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var fixedColumn = arguments[1];
    var prefixCls = this.props.prefixCls;

    if (!this.hasFooter()) {
      return null;
    }
    return _react2["default"].createElement(
      'div',
      { className: prefixCls + '-footer-wrapper' },
      _react2["default"].createElement(_Footer2["default"], _extends({}, renderFooterProps, {
        fixedColumn: fixedColumn,
        ref: _util2["default"].saveRef('footer' + (0, _upperFirst2["default"])(fixedColumn), this),
        onScroll: function onScroll(scrollLeft) {
          _this8.handleFooterScroll(scrollLeft);
        }
      }))
    );
  };

  Table.prototype.renderPager = function renderPager(miniType) {
    var me = this;
    var _state = this.state,
        data = _state.data,
        currentPage = _state.currentPage,
        pageSize = _state.pageSize;
    var _me$props = me.props,
        showPagerTotal = _me$props.showPagerTotal,
        showPager = _me$props.showPager,
        locale = _me$props.locale,
        pagerSizeOptions = _me$props.pagerSizeOptions,
        isMiniPager = _me$props.isMiniPager,
        showPagerSizeChanger = _me$props.showPagerSizeChanger,
        showPagerQuickJumper = _me$props.showPagerQuickJumper,
        showUnknownTotalPager = _me$props.showUnknownTotalPager,
        prefixCls = _me$props.prefixCls;


    if (miniType && data) {
      return _react2["default"].createElement(_uxcorePagination2["default"], { simple: true, current: currentPage, onChange: me.onPageChange.bind(me), total: data.totalCount });
    }

    if (showPager && data) {
      var pagersProps = {
        className: (0, _classnames4["default"])({
          mini: isMiniPager
        }),
        ref: _util2["default"].saveRef('pager', me),
        locale: locale,
        showSizeChanger: showPagerSizeChanger,
        showQuickJumper: showPagerQuickJumper,
        showTotal: showPagerTotal,
        total: data.totalCount,
        onShowSizeChange: me.handleShowSizeChange.bind(me),
        onChange: me.onPageChange.bind(me),
        current: currentPage,
        pageSize: pageSize,
        sizeOptions: pagerSizeOptions
      };
      var pager = _react2["default"].createElement(
        'div',
        { className: prefixCls + '-page' },
        _react2["default"].createElement(_uxcorePagination2["default"], pagersProps)
      );
      if (data.totalCount) {
        if (parseInt(data.totalCount, 10) <= parseInt(pageSize, 10) && !showPagerSizeChanger) {
          return null;
        }
        return pager;
      }if (showUnknownTotalPager) {
        return pager;
      }
    }
    return null;
  };

  Table.prototype.renderMainTable = function renderMainTable(_ref) {
    var renderHeaderProps = _ref.renderHeaderProps,
        renderBodyProps = _ref.renderBodyProps,
        renderFooterProps = _ref.renderFooterProps,
        bodyHeight = _ref.bodyHeight;
    var prefixCls = this.props.prefixCls;

    var style = {};
    return _react2["default"].createElement(
      'div',
      { className: prefixCls + '-main-table', style: style, ref: _util2["default"].saveRef('mainTable', this) },
      this.renderHeader(renderHeaderProps, 'scroll'),
      this.renderTbody(renderBodyProps, bodyHeight, 'scroll'),
      this.renderFooter(renderFooterProps, 'scroll')
    );
  };

  Table.prototype.renderLeftFixedTable = function renderLeftFixedTable(_ref2) {
    var renderHeaderProps = _ref2.renderHeaderProps,
        renderBodyProps = _ref2.renderBodyProps,
        renderFooterProps = _ref2.renderFooterProps,
        bodyHeight = _ref2.bodyHeight;

    if (!this.state.hasFixed || !this.state.hasFixed.hasLeft || !renderBodyProps.data || !renderBodyProps.data.length) {
      return null;
    }
    var _props2 = this.props,
        prefixCls = _props2.prefixCls,
        leftFixedMaxWidth = _props2.leftFixedMaxWidth;

    var style = {
      maxWidth: leftFixedMaxWidth
    };
    return _react2["default"].createElement(
      'div',
      {
        className: (0, _classnames4["default"])(prefixCls + '-left-fixed-table'),
        style: style,
        ref: _util2["default"].saveRef('fixedTable', this)
      },
      this.renderHeader(renderHeaderProps, 'fixed'),
      this.renderTbody(renderBodyProps, bodyHeight, 'fixed'),
      this.renderFooter(renderFooterProps, 'fixed')
    );
  };

  Table.prototype.renderRightFixedTable = function renderRightFixedTable(_ref3) {
    var renderHeaderProps = _ref3.renderHeaderProps,
        renderBodyProps = _ref3.renderBodyProps,
        renderFooterProps = _ref3.renderFooterProps,
        bodyHeight = _ref3.bodyHeight;

    if (!this.state.hasFixed || !this.state.hasFixed.hasRight || !renderBodyProps.data || !renderBodyProps.data.length) {
      return null;
    }
    var prefixCls = this.props.prefixCls;

    return _react2["default"].createElement(
      'div',
      { className: prefixCls + '-right-fixed-table', ref: _util2["default"].saveRef('rightFixedTable', this) },
      this.renderHeader(renderHeaderProps, 'rightFixed'),
      this.renderTbody(renderBodyProps, bodyHeight, 'rightFixed'),
      this.renderFooter(renderFooterProps, 'rightFixed')
    );
  };

  Table.prototype.renderActionBar = function renderActionBar() {
    var _this9 = this;

    var shouldRenderActionBar = function shouldRenderActionBar(config) {
      var shouldRenderAction = false;
      if (!config.useListActionBar) {
        if (config.actionBar) {
          if (Array.isArray(config.actionBar)) {
            if (config.actionBar.length) {
              shouldRenderAction = true;
            }
          } else if (_typeof(config.actionBar) === 'object') {
            for (var i in config.actionBar) {
              if (config.actionBar.hasOwnProperty(i)) {
                if (typeof config.actionBar[i] === 'function') {
                  shouldRenderAction = true;
                  break;
                }
              }
            }
          }
        }
      } else {
        var actionBar = config.actionBar;
        if (actionBar) {
          if (actionBar.showSelectAll || actionBar.buttons && actionBar.buttons.length || typeof actionBar.actionBarTip === 'string' && actionBar.actionBarTip || typeof actionBar.actionBarTip === 'function' && actionBar.actionBarTip() || actionBar.customBarItem || actionBar.rowOrder || actionBar.columnsOrder || actionBar.columnsPicker || actionBar.customView || actionBar.showMiniPager || actionBar.search || actionBar.linkBar) {
            shouldRenderAction = true;
          }
        }
      }
      return shouldRenderAction || config.linkBar && config.linkBar.length || config.showSearch || config.showColumnPicker;
    };

    var me = this;
    var state = me.state,
        props = me.props;

    var data = state.data ? state.data.datas || state.data.data : [];
    var checkStatus = me.getCheckStatus(data);

    if (shouldRenderActionBar(props)) {
      var renderActionProps = {
        actionBarConfig: props.actionBar,
        useListActionBar: props.useListActionBar,
        showColumnPicker: props.showColumnPicker,
        locale: props.locale,
        linkBar: props.linkBar,
        checkStatus: checkStatus,
        data: data,
        currentPage: state.currentPage,
        selectAll: me.selectAll.bind(me),
        checkboxColumnKey: me.state.checkboxColumnKey,
        showSearch: props.showSearch,
        searchBarPlaceholder: props.searchBarPlaceholder,
        columns: me.state.columns,
        width: props.width,
        onSearch: me.handleActionBarSearch,
        showColumnPickerCheckAll: props.showColumnPickerCheckAll,
        handleColumnPickerChange: me.handleColumnPickerChange,
        handleColumnPickerCheckAll: me.handleColumnPickerCheckAll,
        handleColumnOrderChange: me.handleColumnOrderChange,
        key: 'grid-actionbar',
        prefixCls: props.prefixCls + '-actionbar',
        tablePrefixCls: props.prefixCls,
        renderPager: me.renderPager.bind(me),
        useCustomView: me.useCustomView.bind(me)
      };
      return props.fixActionBarToTop ? _react2["default"].createElement(
        _uxcoreSticky2["default"],
        {
          offsetTop: props.fixActionBarOffset
        },
        _react2["default"].createElement(_ActionBar2["default"], _extends({}, renderActionProps, { ref: function ref(c) {
            return _this9.actionBar = c;
          } }))
      ) : _react2["default"].createElement(_ActionBar2["default"], _extends({}, renderActionProps, { ref: function ref(c) {
          return _this9.actionBar = c;
        } }));
    }
    return null;
  };

  Table.prototype.render = function render() {
    var _this10 = this,
        _classnames2;

    var me = this;
    var props = this.props,
        state = this.state;
    // if table is in sub mode, people always want to align the parent
    // and the sub table, so width should not be cared.

    var headerHeight = props.headerHeight,
        fixHeaderOffset = props.fixHeaderOffset;

    var data = state.data ? state.data.datas || state.data.data : [];
    var checkStatus = me.getCheckStatus(data);

    var style = {
      width: props.passedData ? 'auto' : props.width,
      height: props.height
    };
    var actionBarHeight = props.actionBar || props.showSearch ? props.actionBarHeight : 0;
    var pagerHeight = props.showPager && this.state.data && this.state.data.totalCount ? 67 : 0;

    var bodyHeight = void 0;
    if (props.height === 'auto' || props.height === '100%') {
      bodyHeight = props.height;
    } else {
      bodyHeight = parseInt(props.height, 10) - (headerHeight || (this.hasGroup ? 100 : 50)) - actionBarHeight - pagerHeight;
    }

    var commonProps = {
      columns: state.columns,
      width: props.width,
      mode: props.mode,
      renderModel: props.renderModel,
      checkboxColumnKey: me.state.checkboxColumnKey,
      leftFixedMaxWidth: props.leftFixedMaxWidth,
      tablePrefixCls: props.prefixCls,
      getTooltipContainer: props.getTooltipContainer,
      expandIconType: props.expandIconType,
      size: props.size
    };

    var renderBodyProps = _extends({}, commonProps, {
      rowGroupColumn: state.rowGroupColumn,
      mask: state.showMask,
      expandedKeys: state.expandedKeys,
      currentHoverRow: state.currentHoverRow,
      rowGroupActiveKey: state.rowGroupActiveKey,
      data: data,
      treeLoadingIds: this.state.treeLoadingIds,
      bodyHeight: bodyHeight,
      hasFooter: this.hasFooter(),
      prefixCls: props.prefixCls + '-body',
      toggleSubCompOnRowClick: props.toggleSubCompOnRowClick,
      toggleTreeExpandOnRowClick: props.toggleTreeExpandOnRowClick,
      rowSelection: props.rowSelection,
      addRowClassName: props.addRowClassName,
      locale: props.locale,
      emptyText: props.emptyText,
      renderSubComp: this.state.hasFixed && this.state.hasFixed.hasLeft ? null : props.renderSubComp,
      rowHeight: props.rowHeight,
      loadingText: props.loadingText,
      height: bodyHeight,
      levels: props.levels,
      rowGroupKey: props.rowGroupKey,
      footer: props.footer,
      showRowGroupFooter: props.showRowGroupFooter,
      root: this,
      onCollapseChange: function onCollapseChange(activeKeys, key, table) {
        _this10.setState({ rowGroupActiveKey: activeKeys });
        setTimeout(function () {
          props.onRowGroupOpenChange && props.onRowGroupOpenChange(activeKeys, key, table);
        }, 310);
      },
      changeSelected: this.changeSelected,
      handleDataChange: this.handleDataChange,
      attachCellField: this.attachCellField,
      detachCellField: this.detachCellField,
      key: 'table-body',
      defaultRowGroupActiveKeys: props.defaultRowGroupActiveKeys,
      allowActionEventDefault: props.allowActionEventDefault
    });
    var renderHeaderProps = _extends({}, commonProps, {
      activeColumn: state.activeColumn,
      filterColumns: state.filterColumns,
      orderType: state.orderType,
      prefixCls: props.prefixCls + '-header',
      showHeaderBorder: props.showHeaderBorder,
      headerHeight: props.headerHeight,
      checkStatus: checkStatus,
      hasGroup: this.hasGroup,
      selectAll: this.selectAll,
      orderColumnCB: this.handleOrderColumnCB,
      onColumnFilter: this.handleFilter,
      key: 'table-header',
      columnResizeable: props.columnResizeable,
      handleColumnResize: this.handleColumnResize,
      tooltipPlacement: props.tooltipPlacement
    });

    var renderFooterProps = _extends({}, commonProps, {
      data: data,
      footer: props.footer
    });

    var config = {
      renderHeaderProps: renderHeaderProps, renderBodyProps: renderBodyProps, renderFooterProps: renderFooterProps, bodyHeight: bodyHeight
    };

    return _react2["default"].createElement(
      _context2["default"].Provider,
      { value: {
          prefixCls: props.prefixCls
        }
      },
      _react2["default"].createElement(
        'div',
        {
          className: (0, _classnames4["default"])((_classnames2 = {}, _defineProperty(_classnames2, props.prefixCls, true), _defineProperty(_classnames2, props.prefixCls + '-' + props.size + '-size', true), _defineProperty(_classnames2, props.className, !!props.className), _defineProperty(_classnames2, 'kuma-subgrid-mode', !!props.passedData), _defineProperty(_classnames2, props.prefixCls + '-tree-mode', props.renderModel === 'tree'), _defineProperty(_classnames2, props.prefixCls + '-row-group-mode', !!props.rowGroupKey), _defineProperty(_classnames2, props.prefixCls + '__no-data', data.length === 0), _defineProperty(_classnames2, props.prefixCls + '__has-footer', this.hasFooter()), _classnames2)),
          style: style,
          ref: _util2["default"].saveRef('root', this)
        },
        this.renderActionBar(),
        !this.state.customView ? _react2["default"].createElement(
          'div',
          {
            className: props.prefixCls + '-content',
            style: {
              width: props.passedData ? 'auto' : props.width
            }
          },
          this.renderMainTable(config),
          this.renderLeftFixedTable(config),
          this.renderRightFixedTable(config)
        ) : this.state.customView,
        !this.state.removeCustomPager ? this.renderPager() : null
      )
    );
  };

  return Table;
}(_react2["default"].Component);

Table.processColumn = function (props) {
  var state = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var extra = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

  var actualProps = props;
  var columns = (0, _cloneDeep2["default"])(actualProps.jsxcolumns);
  var hasCheckboxColumn = false;
  var hasPercentWidth = false;
  var checkboxColumn = void 0;
  var checkboxColumnKey = void 0;
  for (var i = 0; i < columns.length; i++) {
    var item = columns[i];
    // only one rowSelector can be rendered in Table.
    if (item.type === 'checkbox' || item.type === 'radioSelector' || item.type === 'checkboxSelector') {
      if (item.type === 'checkbox') {
        console.warn("rowSelector using 'type: checkbox' is deprecated," + " use 'type: checkboxSelector' instead.");
      }
      hasCheckboxColumn = true;
      checkboxColumn = item;
      checkboxColumnKey = item.dataKey;
      item.width = item.width || (new RegExp(props.prefixCls + '-border-line').test(actualProps.className) ? '40px' : '32px');
      item.align = item.align || 'left';
    }
    if (item.type === 'money') {
      item.align = item.align || 'right';
      item.delimiter = item.delimiter || ',';
    }
    if (/\d+%/.test('' + item.width)) {
      hasPercentWidth = true;
      var tableWidth = extra.tableWidth || state.tableWidth;
      if (tableWidth) {
        var scrollBarWidth = _util2["default"].measureScrollbar();
        var trueTableWidth = tableWidth - scrollBarWidth;
        item.width = parseFloat(item.width) * trueTableWidth / 100;
      }
    }
  }
  // filter the column which has a dataKey 'jsxchecked' & 'jsxtreeIcon'
  // filter the column whose dataKey is rowGroupKey

  var rowGroupColumn = void 0;

  columns = columns.filter(function (item) {
    if (item.dataKey === undefined) {
      return true;
    }
    if (item.dataKey === actualProps.rowGroupKey) {
      rowGroupColumn = item;
      return false;
    }
    if (item.dataKey === 'jsxchecked' || item.dataKey === 'jsxtreeIcon') {
      return false;
    }
    return true;
  });

  if (!!actualProps.rowSelection && !hasCheckboxColumn) {
    checkboxColumn = {
      dataKey: 'jsxchecked',
      width: new RegExp(props.prefixCls + '-border-line').test(actualProps.className) ? '40px' : '32px',
      type: actualProps.rowSelector,
      align: 'right'
    };
    checkboxColumnKey = 'jsxchecked';
    columns = [checkboxColumn].concat(columns);
  } else if (actualProps.parentHasCheckbox) {
    // no rowSelection but has parentHasCheckbox, render placeholder
    columns = [{
      dataKey: 'jsxwhite',
      width: new RegExp(props.prefixCls + '-border-line').test(actualProps.className) ? '40px' : '32px',
      type: 'empty'
    }].concat(columns);
  }
  if ((actualProps.subComp || actualProps.renderSubComp) && actualProps.renderModel !== 'tree' && (!state.hasFixed || !state.hasFixed.hasLeft)) {
    columns = [{
      dataKey: 'jsxtreeIcon',
      width: '36px',
      type: 'treeIcon'
    }].concat(columns);
  } else if (actualProps.passedData) {
    // no subComp but has passedData, means sub mode, parent should has tree icon,
    // render tree icon placeholder
    columns = [{
      dataKey: 'jsxwhite',
      width: '34px',
      type: 'empty'
    }].concat(columns);
  }
  return {
    columns: columns, checkboxColumn: checkboxColumn, checkboxColumnKey: checkboxColumnKey, hasPercentWidth: hasPercentWidth, rowGroupColumn: rowGroupColumn
  };
};

Table.isColumnsEqual = function (newColumns, oldColumns) {
  // drop the key whose type is function from columns first
  // func key is always not equal in columns cause anonymous function is widely used,
  // so comparing columns with func key is unnecessary.
  var newToCompare = _util2["default"].dropFunc(newColumns);
  var oldToCompare = _util2["default"].dropFunc(oldColumns);
  return (0, _isEqual2["default"])(newToCompare, oldToCompare);
};

Table.getDerivedStateFromProps = function (props, state) {
  var newData = {};
  if (props.pageSize !== state.lastPageSize) {
    newData.pageSize = props.pageSize;
    newData.lastPageSize = props.pageSize;
  }
  if (props.currentPage !== state.lastCurrentPage) {
    newData.currentPage = props.currentPage;
    newData.lastCurrentPage = props.currentPage;
  }
  if (!!props.jsxcolumns && !Table.isColumnsEqual(props.jsxcolumns, state.lastJsxcolumns)) {
    newData = _extends({}, newData, Table.processColumn(props, state), {
      lastJsxcolumns: props.jsxcolumns,
      forceToCheckRight: true
    });
    newData.hasFixed = _util2["default"].hasFixColumn(props);

    // jsxcolumns变更时需要检查activeColumn是否还存在
    var exist = _util2["default"].checkColumnExist(props.jsxcolumns, state.activeColumn);
    if (!exist) {
      newData.activeColumn = undefined;
    }
  }
  if (props.showMask !== state.lastShowMask) {
    newData.showMask = props.showMask;
    newData.lastShowMask = props.showMask;
  }

  return newData;
};

var _initialiseProps = function _initialiseProps() {
  var _this11 = this;

  this.handleColumnResize = function (e, changeWidth, column, node) {
    var columns = (0, _cloneDeep2["default"])(_this11.state.columns);
    columns.map(function (col) {
      if (col.dataKey === column.dataKey) {
        col.width = (parseInt(col.width, 10) || 100) + changeWidth;
      }
    });
    _this11.setState({
      columns: columns
    }, function () {
      _this11.checkRightFixed(true);
      node && (node.style.right = parseInt(node.style.right, 10) + changeWidth + 'px');
    });
  };

  this.handleColumnPickerCheckAll = function (checked) {
    var columns = (0, _cloneDeep2["default"])(_this11.state.columns);
    var notRenderColumns = ['jsxchecked', 'jsxtreeIcon', 'jsxwhite'];
    notRenderColumns.push(_this11.state.checkboxColumnKey);
    for (var i = 0; i < columns.length; i++) {
      var item = columns[i];
      var isGroup = {}.hasOwnProperty.call(item, 'columns') && _typeof(item.columns) === 'object';
      // current column is a group and groupName is right
      if (isGroup) {
        for (var j = 0; j < item.columns.length; j++) {
          var ele = item.columns[j];
          ele.hidden = !checked;
        }
      } else if (notRenderColumns.indexOf(item.dataKey) === -1) {
        item.hidden = !checked;
      }
    }

    _this11.setState({
      columns: columns
    }, function () {
      if (typeof _this11.props.onColumnPick === 'function') {
        _this11.props.onColumnPick((0, _cloneDeep2["default"])(columns));
      }
      _this11.checkRightFixed(true);
    });
  };

  this.handleColumnOrderChange = function (columns) {
    _this11.setState({
      columns: columns
    });
  };

  this.handleHeaderFixedChanged = function (isSticky) {
    if (isSticky) {
      _this11.setState({
        isStickyHeader: isSticky
      });
    }
  };
};

Table.defaultProps = _prop.defaultProps;
Table.propTypes = _prop.propTypes;
Table.displayName = 'Table';
Table.CellField = _uxcoreCellField2["default"];
Table.Constants = _uxcoreConst2["default"];
Table.createCellField = createCellField;

(0, _reactLifecyclesCompat.polyfill)(Table);

exports["default"] = Table;
module.exports = exports['default'];