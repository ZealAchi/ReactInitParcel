'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _propTypes = require('prop-types');

var _propTypes2 = _interopRequireDefault(_propTypes);

var _uxcoreConst = require('uxcore-const');

var _uxcoreConst2 = _interopRequireDefault(_uxcoreConst);

var _classnames4 = require('classnames');

var _classnames5 = _interopRequireDefault(_classnames4);

var _objectAssign = require('object-assign');

var _objectAssign2 = _interopRequireDefault(_objectAssign);

var _isEqual = require('lodash/isEqual');

var _isEqual2 = _interopRequireDefault(_isEqual);

var _cloneDeep = require('lodash/cloneDeep');

var _cloneDeep2 = _interopRequireDefault(_cloneDeep);

var _lie = require('lie');

var _lie2 = _interopRequireDefault(_lie);

var _reactLifecyclesCompat = require('react-lifecycles-compat');

var _uxcoreTooltip = require('uxcore-tooltip');

var _uxcoreTooltip2 = _interopRequireDefault(_uxcoreTooltip);

var _uxcoreIcon = require('uxcore-icon');

var _uxcoreIcon2 = _interopRequireDefault(_uxcoreIcon);

var _uxcoreValidator = require('uxcore-validator');

var _uxcoreValidator2 = _interopRequireDefault(_uxcoreValidator);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

/* eslint-disable class-methods-use-this */
var FormField = function (_React$Component) {
  _inherits(FormField, _React$Component);

  function FormField(props) {
    _classCallCheck(this, FormField);

    var _this = _possibleConstructorReturn(this, _React$Component.call(this, props));

    _this.state = {
      value: props.value,
      formatValue: FormField.formatValue(props.value),
      error: false,
      errMsg: '',
      prevValue: props.value
    };
    return _this;
  }

  FormField.prototype.componentDidMount = function componentDidMount() {
    var me = this;
    if (!me.props.standalone) {
      me.props.attachFormField(me);
      me.props.handleDataChange(me, {
        value: me.props.value,
        pass: true
      }, true);
    }
  };

  FormField.prototype.componentDidUpdate = function componentDidUpdate(prevProps, prevState) {
    var handleDataChange = this.props.handleDataChange;
    var _state = this.state,
        value = _state.value,
        error = _state.error;

    if (handleDataChange && !(0, _isEqual2["default"])(prevState.value, value)) {
      handleDataChange(this, {
        value: value,
        pass: !error
      }, true);
    }
  };

  FormField.prototype.componentWillUnmount = function componentWillUnmount() {
    var _props = this.props,
        standalone = _props.standalone,
        detachFormField = _props.detachFormField;

    if (!standalone) {
      detachFormField(this);
    }
  };

  FormField.getRules = function getRules(props) {
    var asyncValidate = props.asyncValidate,
        jsxrules = props.jsxrules,
        required = props.required,
        requiredErrMsg = props.requiredErrMsg;

    if (asyncValidate || !required || !requiredErrMsg) {
      return jsxrules;
    }
    var emptyCheck = {
      validator: _uxcoreValidator2["default"].isNotEmptyIncludeFalse,
      errMsg: requiredErrMsg || '必填字段'
    };
    if (!jsxrules) {
      return emptyCheck;
    } else {
      if (Array.isArray(jsxrules)) {
        return [].concat(_toConsumableArray(jsxrules), [emptyCheck]);
      } else {
        if ((typeof jsxrules === 'undefined' ? 'undefined' : _typeof(jsxrules)) === 'object' && jsxrules.validator) {
          return [jsxrules, emptyCheck];
        }
      }
    }
  };

  FormField.prototype.getGridLayoutPercent = function getGridLayoutPercent(index) {
    var me = this;
    var gridLayout = me.props.gridLayout || me.props.jsxGridLayout;
    var newGrid = [gridLayout[0] || 6, gridLayout[1] || 12];
    return newGrid[index] * 100 / (24 - (index === 1 ? newGrid[0] : 0)) + '%';
  };

  FormField.prototype.getSize = function getSize() {
    var me = this;
    return me.props.size || me.props.jsxsize;
  };

  FormField.prototype.getProps = function getProps() {
    return this.props;
  };

  FormField.prototype.getLabelContentNode = function getLabelContentNode() {
    return this.labelContent;
  };

  FormField.prototype.getLabelNode = function getLabelNode() {
    return this.label;
  };

  FormField.prototype.getTipsNode = function getTipsNode() {
    return this.tips;
  };

  FormField.prototype.getRequiredNode = function getRequiredNode() {
    return this.required;
  };

  FormField.prototype.getErrorNode = function getErrorNode() {
    return this.errorNode;
  };

  FormField.prototype.getFieldCore = function getFieldCore() {
    return this.fieldCore;
  };

  FormField.prototype.getName = function getName() {
    var jsxname = this.props.jsxname;

    return jsxname;
  };

  FormField.prototype.getValue = function getValue() {
    var value = this.state.value;

    return this.formatValue(value);
  };

  FormField.prototype.setValue = function setValue(value, fromReset, fromPropsChange, next) {
    var me = this;
    var _me$props = me.props,
        standalone = _me$props.standalone,
        validateOnBlur = _me$props.validateOnBlur,
        asyncValidate = _me$props.asyncValidate;

    var newState = {
      value: value,
      formatValue: me.formatValue(value),
      /*
       * why set state fromReset? some field like editor cannot be reset in the common way
       * so set this state to tell the field that you need to reset by yourself.
       */
      fromReset: !!fromReset
    };
    var pass = true;
    // validateOnBlur only support InputFormField & TextAraeFormField now
    if (!fromReset && !standalone && !validateOnBlur) {
      if (!asyncValidate) {
        var validatePass = me.getValidateStatus({ value: value });
        newState = _extends({}, newState, validatePass);
        pass = !validatePass.error;
      } else {
        me.doValidate(undefined, undefined, value);
      }
    }
    if (fromReset && fromPropsChange === undefined) {
      newState.error = false;
    }
    me.setState(newState, function () {
      if (next && typeof next === 'function') {
        next(pass);
      }
    });
  };

  FormField.prototype.getDataProps = function getDataProps() {
    var _this2 = this;

    var dataProps = {};
    Object.keys(this.props).forEach(function (propName) {
      if (/^data-/.test(propName)) {
        dataProps[propName] = _this2.props[propName];
      }
    });
    return dataProps;
  };

  FormField.prototype.getDom = function getDom() {
    return this.fieldRoot;
  };

  FormField.prototype.getValidateStatus = function getValidateStatus(_ref) {
    var force = _ref.force,
        always = _ref.always,
        value = _ref.value;

    return FormField.getValidateStatus({
      force: force, always: always, props: this.props, value: value
    });
  };

  /*
   * Fired when field value changes，update form's state and then trigger re-render.
   * @param fromReset {boolean} if handleDataChange is invoked by form's resetValues,
   */

  FormField.prototype.handleDataChange = function handleDataChange(value, fromReset, silence, fromPropsChange) {
    var me = this;
    var _me$props2 = me.props,
        processValue = _me$props2.processValue,
        handleDataChange = _me$props2.handleDataChange;

    var newValue = typeof processValue === 'function' ? processValue((0, _cloneDeep2["default"])(value)) : value;
    me.setValue(newValue, fromReset, fromPropsChange, function (pass) {
      if (handleDataChange) {
        handleDataChange(me, {
          value: newValue,
          pass: pass
        }, silence);
      }
    });
  };

  /**
   * @return {boolean} if validate pass, return true, or, return false
   * if no rule, it means validate pass.
   */

  FormField.prototype.doValidate = function doValidate(force, always) {
    var _this3 = this;

    var value = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.state.value;

    var status = this.getValidateStatus({ force: force, always: always, value: value });
    if (status.then) {
      return new _lie2["default"](function (resolve) {
        status.then(function (stat) {
          _this3.setState(stat);
          resolve(!stat.error);
        });
      });
    }
    this.setState(status);
    return !status.error;
  };

  /*
   * rule can be an object, containing errMsg & validator,
   * and rule can also be an array containing such objects.
   * this func will check them one by one, and return false
   * unless all rules pass
   */

  FormField.prototype.isDirty = function isDirty(always) {
    var async = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    var value = this.state.value;
    var jsxrules = this.props.jsxrules;

    return FormField.isDirty({
      always: always,
      async: async,
      value: value,
      rules: jsxrules
    });
  };

  FormField.prototype.isMessageError = function isMessageError() {
    var _props2 = this.props,
        standalone = _props2.standalone,
        message = _props2.message;

    return standalone && message && message.type === 'error';
  };

  FormField.prototype.addSpecificClass = function addSpecificClass() {
    return '';
  };

  /*
   * You should rewrite this method，when you need to format the value as you concern.
   */

  FormField.prototype.formatValue = function formatValue(value) {
    return value;
  };

  FormField.prototype.saveRef = function saveRef(refName) {
    var me = this;
    return function (c) {
      me[refName] = c;
    };
  };

  FormField.prototype.shouldLayoutAsGrid = function shouldLayoutAsGrid() {
    var me = this;
    var gridLayout = me.props.gridLayout || me.props.jsxGridLayout;
    var align = me.props.verticalAlign || me.props.jsxVerticalAlign;
    return !align && Array.isArray(gridLayout) && gridLayout.length > 0;
  };

  FormField.prototype.renderTips = function renderTips() {
    var me = this;
    var mode = me.props.jsxmode || me.props.mode;
    var _props3 = this.props,
        jsxtips = _props3.jsxtips,
        formPrefixCls = _props3.formPrefixCls,
        tipInLabel = _props3.tipInLabel,
        showTipAlways = _props3.showTipAlways;

    if ((mode !== _uxcoreConst2["default"].MODE.EDIT || tipInLabel) && !showTipAlways) return null;
    if (me.props.standalone && me.props.message && me.props.message.type === 'tip') {
      return _react2["default"].createElement(
        'li',
        { className: formPrefixCls + '-tips' },
        _react2["default"].createElement(
          'span',
          { ref: me.saveRef('tips'), className: formPrefixCls + '-message-content' },
          me.props.message.message
        )
      );
    }
    if (!!jsxtips && !me.state.error) {
      return _react2["default"].createElement(
        'li',
        { className: formPrefixCls + '-tips' },
        _react2["default"].createElement(
          'span',
          { className: formPrefixCls + '-message-content', ref: me.saveRef('tips') },
          jsxtips
        )
      );
    }
    return null;
  };

  /*
   * You should rewrite this method, when you are developing a new type of form field.
   */

  FormField.prototype.renderField = function renderField() {};

  FormField.prototype.renderFieldAddon = function renderFieldAddon() {
    var _props4 = this.props,
        jsxmode = _props4.jsxmode,
        mode = _props4.mode,
        renderFieldAddon = _props4.renderFieldAddon;

    var trueMode = jsxmode || mode;
    return renderFieldAddon({ mode: trueMode });
  };

  FormField.prototype.renderErrorMsg = function renderErrorMsg() {
    var me = this;
    var formPrefixCls = this.props.formPrefixCls;

    var mode = me.props.jsxmode || me.props.mode;
    if (mode !== _uxcoreConst2["default"].MODE.EDIT) return null;
    if (this.isMessageError()) {
      return _react2["default"].createElement(
        'li',
        { className: formPrefixCls + '-errormsg' },
        _react2["default"].createElement(
          'span',
          { ref: me.saveRef('errorNode'), className: formPrefixCls + '-message-content' },
          me.props.message.message
        )
      );
    }
    if (me.state.error) {
      return _react2["default"].createElement(
        'li',
        { className: formPrefixCls + '-errormsg' },
        _react2["default"].createElement(
          'span',
          { ref: me.saveRef('errorNode'), className: formPrefixCls + '-message-content' },
          me.state.errMsg
        )
      );
    }
    return null;
  };

  FormField.prototype.renderLabelContent = function renderLabelContent() {
    var me = this;
    var contentProps = {
      className: 'label-content',
      ref: me.saveRef('labelContent')
    };
    if (_react2["default"].isValidElement(me.props.jsxlabel)) {
      contentProps.children = me.props.jsxlabel;
    } else {
      contentProps.dangerouslySetInnerHTML = {
        __html: me.props.jsxlabel
      };
    }
    return _react2["default"].createElement('span', contentProps);
  };

  FormField.prototype.renderTipInLabel = function renderTipInLabel() {
    var me = this;
    var mode = me.props.jsxmode || me.props.mode;
    var _props5 = this.props,
        jsxtips = _props5.jsxtips,
        message = _props5.message,
        standalone = _props5.standalone,
        tipInLabel = _props5.tipInLabel,
        jsxprefixCls = _props5.jsxprefixCls;

    if (mode !== _uxcoreConst2["default"].MODE.EDIT || !tipInLabel) return null;
    var tip = standalone ? message.message : jsxtips;
    if (tip) {
      return _react2["default"].createElement(
        _uxcoreTooltip2["default"],
        {
          overlay: _react2["default"].createElement(
            'div',
            { style: { maxWidth: 400 } },
            tip
          ),
          placement: 'topLeft'
        },
        _react2["default"].createElement(_uxcoreIcon2["default"], {
          name: 'tishi-full',
          className: jsxprefixCls + '-tip-icon',
          style: {
            display: 'inline-block',
            verticalAlign: 'top',
            marginLeft: 4
          }
        })
      );
    }
    return null;
  };

  FormField.prototype.renderLabel = function renderLabel() {
    var me = this;
    var mode = me.props.jsxmode || me.props.mode;
    // jsxVerticalAlign is an internal varible.
    var align = me.props.verticalAlign;
    if (align === undefined) {
      align = me.props.jsxVerticalAlign;
    }
    var style = {
      width: me.props.labelWidth
    };
    if (this.shouldLayoutAsGrid()) {
      style.width = this.getGridLayoutPercent(0);
    }
    if (me.props.jsxshowLabel) {
      return _react2["default"].createElement(
        'label',
        {
          key: 'label',
          ref: this.saveRef('label'),
          className: (0, _classnames5["default"])({
            'kuma-label': true,
            'vertical-align': align,
            'label-match-input-height': me.props.labelMatchInputHeight && mode === _uxcoreConst2["default"].MODE.EDIT
          }),
          style: style
        },
        _react2["default"].createElement(
          'span',
          { style: {
              display: me.props.tipInLabel ? 'inline-block' : 'inline',
              maxWidth: 'calc(100% - 20px)'
            }
          },
          _react2["default"].createElement(
            'span',
            { className: 'required', ref: me.saveRef('required') },
            me.props.required && mode === _uxcoreConst2["default"].MODE.EDIT ? '* ' : ''
          ),
          this.renderLabelContent()
        ),
        this.renderTipInLabel()
      );
    }
    return null;
  };

  FormField.prototype.renderContent = function renderContent() {
    var _classnames2;

    var me = this;
    var mode = me.props.jsxmode || me.props.mode;
    var align = me.props.verticalAlign || me.props.jsxVerticalAlign;
    var _me$props3 = me.props,
        jsxshowLabel = _me$props3.jsxshowLabel,
        jsxprefixCls = _me$props3.jsxprefixCls,
        formPrefixCls = _me$props3.formPrefixCls;

    var fieldStyle = {
      width: this.shouldLayoutAsGrid() ? this.getGridLayoutPercent(1) : undefined
    };
    if (me.props.labelMatchInputHeight && mode === _uxcoreConst2["default"].MODE.EDIT) {
      var _classnames;

      var tips = me.renderTips();
      var errorMsg = me.renderErrorMsg();
      return [_react2["default"].createElement(
        'div',
        {
          key: 'content',
          style: {
            display: 'table'
          }
        },
        me.renderLabel(),
        _react2["default"].createElement(
          'ul',
          {
            className: (0, _classnames5["default"])((_classnames = {}, _defineProperty(_classnames, jsxprefixCls + '-content', true), _defineProperty(_classnames, 'view-mode', mode === _uxcoreConst2["default"].MODE.VIEW), _defineProperty(_classnames, 'edit-mode', mode === _uxcoreConst2["default"].MODE.EDIT), _defineProperty(_classnames, 'has-error', !!me.state.error || this.isMessageError()), _classnames)),
            style: fieldStyle
          },
          _react2["default"].createElement(
            'li',
            {
              ref: me.saveRef('fieldCore'),
              className: jsxprefixCls + '-core'
            },
            me.renderField(),
            me.renderFieldAddon()
          )
        )
      ), tips || errorMsg ? _react2["default"].createElement(
        'div',
        {
          key: 'tip',
          className: formPrefixCls + '-tip-box',
          style: {
            display: 'table',
            width: '100%'
          }
        },
        !align && jsxshowLabel ? _react2["default"].createElement('label', {
          className: (0, _classnames5["default"])({
            'kuma-label': true
          }),
          style: {
            width: this.shouldLayoutAsGrid() ? this.getGridLayoutPercent(0) : undefined
          }
        }) : null,
        _react2["default"].createElement(
          'ul',
          { style: fieldStyle },
          me.renderTips(),
          me.renderErrorMsg()
        )
      ) : null];
    }
    return [me.renderLabel(), _react2["default"].createElement(
      'ul',
      {
        key: 'content',
        className: (0, _classnames5["default"])((_classnames2 = {}, _defineProperty(_classnames2, jsxprefixCls + '-content', true), _defineProperty(_classnames2, 'view-mode', mode === _uxcoreConst2["default"].MODE.VIEW), _defineProperty(_classnames2, 'edit-mode', mode === _uxcoreConst2["default"].MODE.EDIT), _defineProperty(_classnames2, 'has-error', !!me.state.error || this.isMessageError()), _classnames2)),
        style: fieldStyle
      },
      _react2["default"].createElement(
        'li',
        {
          key: 'core',
          ref: me.saveRef('fieldCore'),
          className: jsxprefixCls + '-core'
        },
        me.renderField(),
        me.renderFieldAddon()
      ),
      me.renderTips(),
      me.renderErrorMsg()
    )];
  };

  FormField.prototype.render = function render() {
    var _classnames3,
        _this4 = this;

    var me = this;
    var specificCls = me.addSpecificClass();
    var mode = me.props.jsxmode || me.props.mode;
    var align = me.props.verticalAlign || me.props.jsxVerticalAlign;
    var dataProps = this.getDataProps();
    var style = {};
    if (!me.props.standalone) {
      style.width = me.props.jsxflex / me.props.totalFlex * 100 + '%';
    }
    var size = this.getSize();
    return _react2["default"].createElement(
      'div',
      _extends({
        className: (0, _classnames5["default"])((_classnames3 = {}, _defineProperty(_classnames3, me.props.jsxprefixCls, true), _defineProperty(_classnames3, specificCls, !!specificCls), _defineProperty(_classnames3, me.props.jsxprefixCls + '-' + size, !!size), _defineProperty(_classnames3, me.props.className, !!me.props.className), _defineProperty(_classnames3, me.props.jsxprefixCls + '__layout-' + (align ? 'v' : 'h'), true), _defineProperty(_classnames3, me.props.jsxprefixCls + '__view', mode === _uxcoreConst2["default"].MODE.VIEW), _defineProperty(_classnames3, me.props.jsxprefixCls + '__input-box-' + me.props.inputBoxMaxWidth, ['middle', 'large'].indexOf(me.props.inputBoxMaxWidth) !== -1), _defineProperty(_classnames3, me.props.jsxprefixCls + '__all-view', !!me.props.isAllViewMode), _classnames3)),
        style: (0, _objectAssign2["default"])({}, style, {
          display: me.props.jsxshow ? 'table' : 'none'
        }),
        ref: function ref(c) {
          _this4.fieldRoot = c;
        }
      }, dataProps),
      me.renderContent()
    );
  };

  return FormField;
}(_react2["default"].Component);

FormField.formatValue = function (value) {
  return value;
};

FormField.isDirty = function (_ref2) {
  var always = _ref2.always,
      _ref2$async = _ref2.async,
      async = _ref2$async === undefined ? false : _ref2$async,
      value = _ref2.value,
      _ref2$rules = _ref2.rules,
      rules = _ref2$rules === undefined ? [] : _ref2$rules;

  var isDirty = false;
  var errMsg = '';
  if (!async) {
    if ((typeof rules === 'undefined' ? 'undefined' : _typeof(rules)) === 'object' && !Array.isArray(rules)) {
      isDirty = always === undefined ? !rules.validator(value) : !always;
      errMsg = rules.errMsg;
    } else if (Array.isArray(rules)) {
      for (var i = 0; i < rules.length; i++) {
        isDirty = always === undefined ? !rules[i].validator(value) : !always;
        if (isDirty) {
          errMsg = rules[i].errMsg;

          break;
        }
      }
    }
    return {
      isDirty: isDirty,
      errMsg: errMsg
    };
  }
  if (typeof rules !== 'function') {
    console.error('Form Validate: In async validation mode,' + ' jsxrules(rules) should be a function');
    return {
      isDirty: false
    };
  }
  return new _lie2["default"](function (resolve, reject) {
    rules(value, reject, resolve);
  });
};

FormField.getValidateStatus = function (_ref3) {
  var force = _ref3.force,
      always = _ref3.always,
      props = _ref3.props,
      value = _ref3.value;

  var instant = true;
  var async = props.asyncValidate || false;
  var defaultPassStatus = {
    error: false
  };
  if (props.instantValidate !== undefined) {
    instant = props.instantValidate;
  } else {
    instant = props.jsxinstant;
  }
  var rules = FormField.getRules(props);
  // `force` has the top priority, `undefined` is not equal to `false`
  // `instant` has the sceond priority here
  // eternalsky@2016.03.15
  if (force === true || force !== false && instant) {
    if (rules) {
      if (!async) {
        var error = FormField.isDirty({ always: always, value: value, rules: rules });
        return {
          error: error.isDirty,
          errMsg: error.errMsg
        };
      }
      return new _lie2["default"](function (resolve) {
        FormField.isDirty({
          always: always, async: async, rules: rules, value: value
        }).then(function (errMsg) {
          resolve({
            error: true,
            errMsg: errMsg
          });
        })["catch"](function (err) {
          if ((typeof err === 'undefined' ? 'undefined' : _typeof(err)) === 'object' && err.stack) {
            console.error(err.stack);
          } else {
            resolve(defaultPassStatus);
          }
        });
      });
    }
    return defaultPassStatus;
  }
  return defaultPassStatus;
};

FormField.getDerivedStateFromProps = function (nextProps, prevState) {
  var processValue = nextProps.processValue,
      value = nextProps.value;

  if (!(0, _isEqual2["default"])(value, prevState.prevValue)) {
    var newValue = typeof processValue === 'function' ? processValue((0, _cloneDeep2["default"])(value)) : value;
    var newState = {
      value: newValue,
      formatValue: FormField.formatValue(value),
      fromReset: true,
      prevValue: value
    };
    return newState;
  }
  return null;
};

FormField.propTypes = {
  instantValidate: _propTypes2["default"].bool,
  verticalAlign: _propTypes2["default"].bool,
  labelMatchInputHeight: _propTypes2["default"].bool,
  value: _propTypes2["default"].any,
  jsxshow: _propTypes2["default"].bool,
  mode: _propTypes2["default"].string,
  jsxmode: _propTypes2["default"].string,
  jsxshowLabel: _propTypes2["default"].bool,
  jsxprefixCls: _propTypes2["default"].string,
  jsxflex: _propTypes2["default"].number,
  jsxname: _propTypes2["default"].string.isRequired,
  jsxlabel: _propTypes2["default"].node,
  jsxtips: _propTypes2["default"].string,
  jsxrules: _propTypes2["default"].oneOfType([_propTypes2["default"].object, _propTypes2["default"].array, _propTypes2["default"].func]),
  totalFlex: _propTypes2["default"].number,
  standalone: _propTypes2["default"].bool,
  required: _propTypes2["default"].bool,
  attachFormField: _propTypes2["default"].func,
  detachFormField: _propTypes2["default"].func,
  getValues: _propTypes2["default"].func,
  resetValues: _propTypes2["default"].func,
  handleDataChange: _propTypes2["default"].func,
  processValue: _propTypes2["default"].func,
  style: _propTypes2["default"].object,
  labelWidth: _propTypes2["default"].oneOfType([_propTypes2["default"].string, _propTypes2["default"].number]),
  inputBoxMaxWidth: _propTypes2["default"].oneOf(['middle', 'large']),
  gridLayout: _propTypes2["default"].array,
  message: _propTypes2["default"].object,
  renderFieldAddon: _propTypes2["default"].func,
  formPrefixCls: _propTypes2["default"].string,
  tipInLabel: _propTypes2["default"].bool,
  requiredErrMsg: _propTypes2["default"].string,
  showTipAlways: _propTypes2["default"].bool
};

FormField.defaultProps = {
  labelMatchInputHeight: false,
  jsxshow: true,
  jsxshowLabel: true,
  jsxprefixCls: 'kuma-uxform-field',
  formPrefixCls: 'kuma-uxform',
  jsxflex: 1,
  jsxlabel: '',
  jsxtips: '',
  standalone: false,
  mode: _uxcoreConst2["default"].MODE.EDIT,
  required: false,
  renderFieldAddon: function renderFieldAddon() {},
  attachFormField: undefined,
  detachFormField: undefined,
  getValues: undefined,
  resetValues: undefined,
  handleDataChange: undefined,
  processValue: undefined,
  style: {},
  labelWidth: undefined,
  inputBoxMaxWidth: undefined,
  gridLayout: undefined,
  message: undefined,
  instantValidate: undefined,
  verticalAlign: undefined,
  value: undefined,
  jsxmode: undefined,
  jsxrules: undefined,
  totalFlex: undefined,
  tipInLabel: false,
  requiredErrMsg: '',
  showTipAlways: false
};

FormField.displayName = 'FormField';

(0, _reactLifecyclesCompat.polyfill)(FormField);

exports["default"] = FormField;
module.exports = exports['default'];