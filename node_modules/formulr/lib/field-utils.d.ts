import { FieldModel } from './models/field';
/**
 * `const callback = useMAppend(foo, bar, baz)`
 *
 * is equal to
 * ```js
 * const callback = useCallback(arg => {
 *   foo(arg);
 *   bar(arg);
 *   baz(arg);
 * }, [foo, bar, baz])
 * ```
 */
export declare function useMAppend<T>(...fns: ((t: T) => void)[]): (t: T) => void;
/**
 * `const callback = usePipe(foo, bar, baz)`
 *
 * is equal to
 * ```js
 * const callback = useMemo(() => arg => {
 *  return baz(bar(foo(arg)))
 * }, [foo, bar, baz])
 * ```
 */
export declare function usePipe<T0, T1, T2>(fn0: (t0: T0) => T1, fn1: (t1: T1) => T2): (t0: T0) => T2;
export declare function usePipe<T0, T1, T2, T3>(fn0: (t0: T0) => T1, fn1: (t1: T1) => T2, fn2: (t2: T2) => T3): (t0: T0) => T3;
export declare function usePipe<T0, T1, T2, T3, T4>(fn0: (t0: T0) => T1, fn1: (t1: T1) => T2, fn2: (t2: T2) => T3, fn3: (t3: T3) => T4): (t0: T0) => T4;
export declare function usePipe<T0, T1, T2, T3, T4, T5>(fn0: (t0: T0) => T1, fn1: (t1: T1) => T2, fn2: (t2: T2) => T3, fn3: (t3: T3) => T4, fn4: (t4: T4) => T5): (t0: T0) => T5;
export declare function usePipe<T0, T1, T2, T3, T4, T5, T6>(fn0: (t0: T0) => T1, fn1: (t1: T1) => T2, fn2: (t2: T2) => T3, fn3: (t3: T3) => T4, fn4: (t4: T4) => T5, fn5: (t5: T5) => T6): (t0: T0) => T6;
export declare function usePipe<T0, T1, T2, T3, T4, T5, T6, T7>(fn0: (t0: T0) => T1, fn1: (t1: T1) => T2, fn2: (t2: T2) => T3, fn3: (t3: T3) => T4, fn4: (t4: T4) => T5, fn5: (t5: T5) => T6, fn6: (t6: T6) => T7): (t0: T0) => T7;
export declare function usePipe<T0, T1, T2, T3, T4, T5, T6, T7, T8>(fn0: (t0: T0) => T1, fn1: (t1: T1) => T2, fn2: (t2: T2) => T3, fn3: (t3: T3) => T4, fn4: (t4: T4) => T5, fn5: (t5: T5) => T6, fn6: (t6: T6) => T7, fn7: (t7: T7) => T8): (t0: T0) => T8;
/**
 * 生成一个默认的`onChange`回调，这个回调会触发`model.validate`
 * 如果不需要在onChange的时候触发校验，如下即可：
 * ```js
 * const onChange = useCallback(value => model.value = value, [model]);
 * ```
 * 例如是一个`input`：
 * ```ts
 * const onChange = useCallback((value: React.ChangeEvent<HTMLInputElement>) => {
 *   model.value = e.target.value;
 * }, [model]);
 * ```
 * 可以配合usePipe使用：
 * ```js
 * function mapEventToValue(e) {
 *   return e.target.value;
 * }
 * function Foo() {
 *   const onChange = FieldUtils.usePipe(
 *     mapEventToValue,
 *     FieldUtils.makeChangeHandler(model),
 *   );
 * }
 * ```
 */
export declare function makeChangeHandler<Value>(model: FieldModel<Value>, option?: number): (value: Value) => void;
/**
 * 生成一组 `onCompositionStart` 和 `onCompositionEnd` 的回调函数，用于跟踪输入法 composition 的状态，
 * 这个状态会写到 `model.isCompositing` 字段上。
 * @param model 用于记录状态的 `model` 对象
 */
export declare function useCompositionHandler<Value>(model: FieldModel<Value>): {
    onCompositionStart(): void;
    onCompositionEnd(): void;
};
//# sourceMappingURL=field-utils.d.ts.map