import { useCallback, useMemo, useRef } from 'react';
import { unstable_IdlePriority as IdlePriority, unstable_scheduleCallback as scheduleCallback, } from 'scheduler';
import { ValidateOption } from './validate';
/**
 * `const callback = useMAppend(foo, bar, baz)`
 *
 * is equal to
 * ```js
 * const callback = useCallback(arg => {
 *   foo(arg);
 *   bar(arg);
 *   baz(arg);
 * }, [foo, bar, baz])
 * ```
 */
export function useMAppend() {
    var fns = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        fns[_i] = arguments[_i];
    }
    return useCallback(function (value) {
        for (var i = 0; i < fns.length; i += 1) {
            var f = fns[i];
            f(value);
        }
    }, fns);
}
export function usePipe() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
    }
    return useMemo(function () {
        var fn = args.reduceRight(function (next, f) { return function (arg) { return next(f(arg)); }; }, function (arg) { return arg; });
        return function (t) { return fn(t); };
    }, args);
}
/**
 * 生成一个默认的`onChange`回调，这个回调会触发`model.validate`
 * 如果不需要在onChange的时候触发校验，如下即可：
 * ```js
 * const onChange = useCallback(value => model.value = value, [model]);
 * ```
 * 例如是一个`input`：
 * ```ts
 * const onChange = useCallback((value: React.ChangeEvent<HTMLInputElement>) => {
 *   model.value = e.target.value;
 * }, [model]);
 * ```
 * 可以配合usePipe使用：
 * ```js
 * function mapEventToValue(e) {
 *   return e.target.value;
 * }
 * function Foo() {
 *   const onChange = FieldUtils.usePipe(
 *     mapEventToValue,
 *     FieldUtils.makeChangeHandler(model),
 *   );
 * }
 * ```
 */
export function makeChangeHandler(model, option) {
    if (option === void 0) { option = ValidateOption.Default | ValidateOption.ExcludePristine; }
    var taskRef = useRef(null);
    var optionRef = useRef(option);
    optionRef.current = option;
    return useCallback(function (value) {
        model.value = value;
        if (model.isCompositing) {
            return;
        }
        if (!taskRef.current) {
            taskRef.current = scheduleCallback(IdlePriority, function () {
                taskRef.current = null;
                model.validate(optionRef.current);
            });
        }
    }, [model]);
}
/**
 * 生成一组 `onCompositionStart` 和 `onCompositionEnd` 的回调函数，用于跟踪输入法 composition 的状态，
 * 这个状态会写到 `model.isCompositing` 字段上。
 * @param model 用于记录状态的 `model` 对象
 */
export function useCompositionHandler(model) {
    return useMemo(function () { return ({
        onCompositionStart: function () {
            model.isCompositing = true;
        },
        onCompositionEnd: function () {
            model.isCompositing = false;
        },
    }); }, [model]);
}
